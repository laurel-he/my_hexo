{"meta":{"title":"贺小娇的博客","subtitle":"技术博客","description":"","author":"Laurel He","url":"http://www.hexiaojiao.top","root":"/"},"pages":[{"title":"about","date":"2020-05-13T04:27:04.000Z","updated":"2020-07-08T11:28:40.340Z","comments":true,"path":"about/index.html","permalink":"http://www.hexiaojiao.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-13T04:26:47.000Z","updated":"2020-07-08T11:28:40.340Z","comments":true,"path":"categories/index.html","permalink":"http://www.hexiaojiao.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-13T04:26:38.000Z","updated":"2020-07-08T11:28:40.346Z","comments":true,"path":"tags/index.html","permalink":"http://www.hexiaojiao.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习计划","slug":"learn_main","date":"2020-07-08T12:00:40.000Z","updated":"2020-07-08T12:16:32.598Z","comments":true,"path":"2020/07/08/learn_main/","link":"","permalink":"http://www.hexiaojiao.top/2020/07/08/learn_main/","excerpt":"","text":"语言： 继续学习go python php操作系统：深入了解linux前端：es6 react熟悉TCP/IP、HTTP等协议 socket网络编程开发尝试对已完成的项目进行压测","categories":[],"tags":[]},{"title":"fit02","slug":"fit02","date":"2020-07-08T11:28:40.335Z","updated":"2020-07-08T11:28:40.335Z","comments":true,"path":"2020/07/08/fit02/","link":"","permalink":"http://www.hexiaojiao.top/2020/07/08/fit02/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"减肥日记-介绍","slug":"fit01","date":"2020-05-23T03:50:00.000Z","updated":"2020-07-09T03:24:28.231Z","comments":true,"path":"2020/05/23/fit01/","link":"","permalink":"http://www.hexiaojiao.top/2020/05/23/fit01/","excerpt":"","text":"创立原因及目标我的表姐要在圣诞节前一天结婚（不是崇洋媚外，只是那时候恰好是个良辰吉日，我们老家又比较喜欢冬天结婚，这样很多亲戚都回家了）。算下来现在距离那天也差不多二百多天，我如果能够成功减肥，这样也不至于在她其他漂亮伴娘的衬托下给她丢脸了（这其中关系比较复杂，就不细说了）。基于以上原因，我创立了一个200天减肥法，在200天内，以一个小基数（虽然我120斤也不算小基数了）的情况，减肥20斤左右。 如何执行我定下的这个200天减肥计划是可以立即执行的，而不是说要先做什么准备，因为如果准备时间过长，或者要准备的东西太多了，人很可能在这个时候就放弃。但是既然是减肥，怎么可能什么准备都没有呢？当然是有的，只不过准备时间也包含在了减肥时间以内，这样就可以直接开始了。而且我这个计划也不会太激进，避免人产生逆反心理。毕竟我也的确是一个好吃懒做的人，我特别爱吃火锅，烤串，辣条，又特别讨厌运动。从刚上大学就开始琢磨着减肥，到如今也已经六年过去了，体重还是120，真是可怕。 具体信息整个200天减肥计划分成了8个阶段，为了避免放弃，避免产生逆反心理，避免反弹，我实在是做了很多前期调研。自己几斤几两我还是知道的，什么21天减肥法，轻断食，各种减肥操，跑步我都试过，最后无一例外全部反弹了，大三的时候我曾经瘦到过102斤，可惜最终也没能保持住，半年不到就反弹回来了，所以说，我需要一个稳妥的，进度也许不够快但是绝对有效的减肥方案。 概述这八个阶段分别是:10天适应期，20天习惯养成期，50天正常减肥期（上），20天疯狂减脂期，10天塑身期，50天正常减肥期（下），20天恢复期，20天稳定期 分条解析10天适应期最终目标适应期的最终目标非常简单，就是十天的时间，把长期处于996，生活作息极其不规律的自己变成一个作息规律，已经为减肥做好了准备的自己，严格来说，就是一个准备阶段。既然是准备阶段，自然要求不会太苛刻，只有几点基本要求:形成良好的饮食，睡眠，喝水等习惯，绝对不可以暴饮暴食，不能说预料到接下来会有很长一段时间要开始减肥了，就趁现在疯狂进食。这个阶段需要形成良好的生活习惯，为后期打好基础。 目标解析维持良好的睡眠每天至少睡6.5小时（因为我是程序员，而且996，偶尔还会加班，所以说至少6.5，正常来说要减肥每天起码要睡7－8小时，我大部分都可以控制到这个时间） 对食物的控制开始注意食物搭配，保持吃饭规律，慢慢形成少食多餐的习惯，拒绝零食（如果实在想吃可以吃一些不是零食的小吃，比如烤冷面，手抓饼等，前提是这些小吃会占据一顿饭） 放松压力这没什么好说的，比较唯心，就是舒缓情绪，不要过分紧张等等 物品准备这十天准备期可以买一些减肥必备的物品，牌子不重要，多看一些评价自然知道好不好了（1）燕麦（最好带坚果的，可以选择含有少量糖的，不然太难吃了，很可能吃一半就放弃了，这可是将来的晚餐，别变成了摆设）（2）瑜伽垫（可以选择厚一些的）（3）滚轴（放松小腿用）（4）运动套装（至少两件运动内衣，跑步用的裤子）（5）运动鞋（舒适，性价比高就可以）（6）坚果（选评价高的就行）（7）全麦面包（或者其他类似的可增加饱腹感，能量又不高的食物）（8）运动用手机包还有其他必须有但是一般人都有的东西：耳机（最好是蓝牙耳机），体重秤，软尺（量腰围用） 其他准备初始体重：120斤（60kg）目标体重：97（58.5kg）#阶段划分减肥时间总共200天，以下是按照不同阶段进行时间划分##适应期10天，此阶段需要达到的目标如下：（1）逐渐形成规律的睡眠时间：6.5-8.5小时（2）逐步减少食量","categories":[{"name":"生活","slug":"生活","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/"},{"name":"减肥","slug":"生活/减肥","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/%E5%87%8F%E8%82%A5/"},{"name":"适应期","slug":"生活/减肥/适应期","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/%E5%87%8F%E8%82%A5/%E9%80%82%E5%BA%94%E6%9C%9F/"}],"tags":[{"name":"减肥","slug":"减肥","permalink":"http://www.hexiaojiao.top/tags/%E5%87%8F%E8%82%A5/"}]},{"title":"kustomize使用文档","slug":"kustomize01","date":"2020-05-21T03:00:00.000Z","updated":"2020-07-09T03:18:56.570Z","comments":true,"path":"2020/05/21/kustomize01/","link":"","permalink":"http://www.hexiaojiao.top/2020/05/21/kustomize01/","excerpt":"","text":"","categories":[{"name":"容器","slug":"容器","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/"},{"name":"k8s","slug":"容器/k8s","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/"},{"name":"kustomize","slug":"容器/k8s/kustomize","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/kustomize/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"kubenetes权威指南1-2章","slug":"k8s01","date":"2020-05-16T10:00:00.000Z","updated":"2020-07-09T03:14:53.902Z","comments":true,"path":"2020/05/16/k8s01/","link":"","permalink":"http://www.hexiaojiao.top/2020/05/16/k8s01/","excerpt":"","text":"kubenetes是什么k8s是一个全新的基于容器技术的分布式架构领先方案，一个开放的开发平台，一个完备的分布式系统支撑平台 k8s重要资源对象介绍Master概念介绍k8s中的Master指的是集群控制节点，在每个集群里都需要有一个Master来负责整个集群的管理和控制。 关键进程（1）Kubenetes API Server(kube-apiserver):提供了HTTP Rest接口的额关键服务进程，是kubenetes里所有资源的增删改查等操作的唯一入口，也是集群控制的入口进程（2）kubenetes Controller Manager(kube-controller-manager):kubenetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的大总管（3）Kubenetes Scheduler(kube-scheduler):负责资源调度(Pod调度)的进程，相当于哦公交公司的调度室 Node概念介绍除了Master,Kubenetes集群中的其他机器被称为Node。Node是集群中的工作负载节点，每个Node都会被Master分配一些工作负载(Docker容器)，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上 关键进程（1）kubelet:负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，，实现集群管理的基本功能（2）kube-proxy:实现kubenetes Service的通信与负载均衡的重要组件（3）Docker Engine：负责本机的容器的创建和管理工作 Pod概念介绍在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元. 部分概念（1）可以设置限额的计算资源有CPU和Memory两种： &nbsp;&nbsp;通常以千分之一的CPU配额为最小单位，用m来表示 &nbsp;&nbsp;Memory配额也是一个绝对值，单位是内存字节数（2）Event是一个事件的记录，记录了事件的最早产生事件，最后重现事件，重复次数，发起者，类型，以及导致此事件的原因等众多信息。 Label概念一个Label是一个key=value的键值对,可类似于sql查询语句一样来进行查询 DeploymentDeployment内部使用了Replica Set来实现目的 kubectl的create命令和apply命令的区别kubectl create： （1）kubectl create命令，是先删除所有现有的东西，重新根据yaml文件生成新的。所以要求yaml文件中的配置必须是完整的 （2）kubectl create命令，用同一个yaml 文件执行替换replace命令，将会不成功，fail掉。 kubectl apply： kubectl apply命令，根据配置文件里面列出来的内容，升级现有的。所以yaml文件的内容可以只写需要升级的属性","categories":[{"name":"容器","slug":"容器","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/"},{"name":"k8s","slug":"容器/k8s","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/"},{"name":"kubenetes权威指南","slug":"容器/k8s/kubenetes权威指南","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/kubenetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"设计模式从头学习-面向对象设计原则概述","slug":"design_pattern02","date":"2020-05-07T12:20:10.000Z","updated":"2020-07-09T03:17:16.812Z","comments":true,"path":"2020/05/07/design_pattern02/","link":"","permalink":"http://www.hexiaojiao.top/2020/05/07/design_pattern02/","excerpt":"","text":"","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"面向对象设计原则","slug":"学习/设计模式/面向对象设计原则","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"设计模式从头学习-前言","slug":"design_patter01","date":"2020-05-07T12:13:10.000Z","updated":"2020-07-09T03:18:21.379Z","comments":true,"path":"2020/05/07/design_patter01/","link":"","permalink":"http://www.hexiaojiao.top/2020/05/07/design_patter01/","excerpt":"","text":"注意本文参考了书籍《大话设计模式》和文章从招式与内功谈起——设计模式概述#写作初衷我有空的时候就会学习一下设计模式，零零散散半年过去了，真正能够静下心来学习设计模式的事件少之又少，而且很多模式例如单例模式，命令模式等我学过后就忘了，让我现在再复述或者使用我又需要重新去学一下，因此我抛弃以前学习的零零散散的与设计模式相关的东西，尝试从头再学一次，边学边使用，并做好详细的笔记，以后可以直接翻阅。#设计模式的作用(1)设计模式经过多年的使用和实践，包含了大量成功的，可维护可复用的设计方案，在很多情况下，设计模式可以提高开发效率，节约时间(2)设计模式跨语言、跨平台、跨应用、跨国界，提供了通用的词汇和使用方式，节约交流时间(3)大部分设计模式都兼顾了系统的可重用性和扩展性，这使很多系统可以重用，减少代码重复(4)合理使用设计模式有助于别人理解自己的代码(5)有助于更为深刻地理解面对对象编程#如何掌握设计模式a.这个设计模式的意图是什么b.它要解决一个什么问题c.什么时候可以使用它d.它是如何解决问题的e.掌握它的结构图f.记住它的关键代码g.能够想到至少两个它的应用实例，一个生活中的，一个软件中的h.这个模式的优缺点是什么i.在使用时要注意什么#注意事项（1）最好的掌握设计模式的方法是使用它们（2）千万不要滥用模式","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"《第一本docker书》学习笔记01","slug":"docker01","date":"2020-04-21T13:03:10.000Z","updated":"2020-07-09T03:19:05.372Z","comments":true,"path":"2020/04/21/docker01/","link":"","permalink":"http://www.hexiaojiao.top/2020/04/21/docker01/","excerpt":"","text":"Docker与配置管理docker的核心组件（1）docker客户端和服务器，也称为docker引擎（2）docker镜像（3）Registry（4）Docker容器 基本使用docker info查看docker程序是否存在，功能是否正常 docker exec(docker run)docker run 命令提供了docker容器的创建到启动的功能(1)-i:保证容器STDIN是开启的(2)-t:为要撞见的容器分配一个伪tty终端docker exec -it backend_jiapin /bin/bash","categories":[{"name":"docker","slug":"docker","permalink":"http://www.hexiaojiao.top/categories/docker/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"php多维数组相关处理","slug":"multiArr","date":"2020-04-16T10:27:44.000Z","updated":"2020-07-09T03:21:05.413Z","comments":true,"path":"2020/04/16/multiArr/","link":"","permalink":"http://www.hexiaojiao.top/2020/04/16/multiArr/","excerpt":"","text":"使用场景在工作中遇到了两次需要把不确定维度的多维数组渲染出来的情况，且还需要修改值和结构，如果使用json-patch会受到限制（需要根据不同的情况打补丁，且由于结构不一定一致，打补丁可能会错误地修改某些文件），因此需要自行设计批量修改如yaml,json等类似于多级结构的方法 具体解析多维数组转化的json前端渲染结构不固定,获取对应的json，ts实现 12345678910111213141516171819202122232425formatJsonData &#x3D; (obj: any, name: string, moduleName?: string, getModuleName?: string): any[] &#x3D;&gt; &#123; const arr: any[] &#x3D; [] if (Object.keys(obj)) &#123; let keys &#x3D; Object.keys(obj); let i &#x3D; 0; return keys.map((items) &#x3D;&gt; &#123; i++; if (obj[items] instanceof Object) &#123; let itemRes &#x3D; items; if (obj[items][&#39;type&#39;]) &#123; itemRes &#x3D; obj[items][&#39;type&#39;]; &#125; const names &#x3D; name + &#39;&#x3D;&#39; + itemRes return this.formatJsonData(obj[items], names, moduleName); &#125; else &#123; const resItems &#x3D; name + &#39;&#x3D;&#39; + items; this.routesValue.set(resItems, obj[items]) if (getModuleName &amp;&amp; resItems &#x3D;&#x3D;&#x3D; getModuleName) &#123; return obj[items]; &#125; &#125; &#125;); &#125; return arr&#125; 结构不固定，根据json获取对应的值，php实现： 1234567891011121314151617181920212223&lt;?php/** * 将数组格式化为mongo可用的filter * @param array $arr * @param string $origin * @return array */ private function formatArr2MongoFilter(array $arr, string $origin = 'data'): array &#123; if (array_keys($arr)) &#123; $keys = array_keys($arr); foreach ($keys as $key) &#123; if (is_array($arr[$key])) &#123; $resName = $origin . '.' . $key; return $this-&gt;formatArr2MongoFilter($arr[$key], $resName); &#125; else &#123; $resName = $origin . '.' . $key; return ['mongoFilter' =&gt; $resName, 'value' =&gt; $arr[$key]]; &#125; &#125; &#125; &#125;?&gt; 比较两个多维数组获取差异1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * 比较多维数组获取差异值 * @param $array1 * @param $array2 * @return int */ private function array_diff_assoc_recursive($array1, $array2) &#123; foreach($array1 as $key =&gt; $value) &#123; if(is_array($value)) &#123; if(!isset($array2[$key])) &#123; $difference[$key] = $value; &#125; elseif(!is_array($array2[$key])) &#123; $difference[$key] = $value; &#125; else &#123; $new_diff = $this-&gt;array_diff_assoc_recursive($value, $array2[$key]); if($new_diff != FALSE) &#123; $difference[$key] = $new_diff; &#125; &#125; &#125; elseif(!isset($array2[$key]) || $array2[$key] != $value) &#123; $difference[$key] = $value; &#125; &#125; return !isset($difference) ? 0 : $difference; &#125;?&gt;","categories":[{"name":"php","slug":"php","permalink":"http://www.hexiaojiao.top/categories/php/"}],"tags":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"}]},{"title":"linux命令大全","slug":"linuxOpe","date":"2020-02-27T10:00:00.000Z","updated":"2020-07-09T03:15:01.317Z","comments":true,"path":"2020/02/27/linuxOpe/","link":"","permalink":"http://www.hexiaojiao.top/2020/02/27/linuxOpe/","excerpt":"","text":"系统信息arch描述 显示机器的处理器架构举例 uname描述 显示机器的处理器架构参数 -a或–all 显示全部的信息。-m或–machine 显示电脑类型。-n或-nodename 显示在网络上的主机名称。-r或–release 显示操作系统的发行编号。-s或–sysname 显示操作系统名称。-v 显示操作系统的版本。–help 显示帮助。–version 显示版本信息。举例 dmidecode描述 显示硬件信息，不常用，可忽略 开关机shutdown描述 关机或重启参数 -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。举例 shutdown -h now //立即关机 shutdown -r now //立即重启reboot描述 重启参数 -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 logout描述 登出系统###","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"操作系统/linux","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"},{"name":"系统相关","slug":"操作系统/linux/系统相关","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"linux命令大全","slug":"linuxUse","date":"2020-02-27T10:00:00.000Z","updated":"2020-07-09T03:17:43.649Z","comments":true,"path":"2020/02/27/linuxUse/","link":"","permalink":"http://www.hexiaojiao.top/2020/02/27/linuxUse/","excerpt":"","text":"文件操作cat描述 查看文件内容参数 -n 或 –number 由 1 开始对所有输出的行数编号-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行-v 或 –show-nonprinting举例1 从键盘创建一个文件：2 将几个文件合并成一个文件： cd描述","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"操作系统/linux","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"},{"name":"文件相关","slug":"操作系统/linux/文件相关","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"计算相关","slug":"codeCollect","date":"2020-02-25T12:10:10.000Z","updated":"2020-07-09T03:21:33.918Z","comments":true,"path":"2020/02/25/codeCollect/","link":"","permalink":"http://www.hexiaojiao.top/2020/02/25/codeCollect/","excerpt":"","text":"1 计算矩形是否相交描述给定两个矩形的左上角起始点坐标和矩形的宽，高，计算这两个矩形是否相交分析 1 矩形1左上角坐标p1,右下角坐标p2,矩形2左上角坐标p3,右下角坐标p4 2 M点坐标为P1与P3点在X方向较大值与Y方向较大值的交点 3 N点坐标为P2与P4点在X方向较小值与Y方向较小值的交点 4 如果M点的X坐标和Y坐标值均比N点相应的X坐标和Y坐标值小，亦即M和N可以分别构成一个矩形的左上角点和右上角点，则两矩形相交；其余情况则不相交 代码 12345678910111213141516171819202122&lt;?phpfunction checkRectInterSect($rect1, $rect2) &#123; $x1 = $rect1['x']; $w1 = $rect1['w']; $y1 = $rect1['y']; $h1 = $rect1['h']; $x2 = $rect2['x']; $w2 = $rect2['w']; $y2 = $rect2['y']; $h2 = $rect2['h']; $p1 = [$x1, $y1]; $p2 = [$x1 + $w1, $y1 + $h1]; $p3 = [$x2, $y2]; $p4 = [$x2 + $w2, $y2 + $h2]; $M = [max($p1[0], $p3[0]), max($p1[1], $p1[1])]; $N = [min($p2[0], $p4[0]), min($p2[1], $p4[1])]; if ($M[0] &lt; $N[0] &amp;&amp; $M[1] &lt; $N[1]) &#123; return true; &#125; else &#123; return false; &#125; &#125;?&gt; 2 json转csv描述需要将数据库数据导出为csv文件代码 1234567891011121314151617181920212223242526&lt;?php function getCsvData(int $limit = 1000, int $skip = 0, string $ageId = '') &#123; $data = $this-&gt;dao-&gt;conn-&gt;query(['faceItems' =&gt; ['$in' =&gt; [$ageId]], 'status' =&gt; 2, 'apiCheckPass' =&gt; true], null, ['limit' =&gt; $limit, 'skip' =&gt; $skip]); foreach ($data as $v) &#123; foreach ($v as $key =&gt; $values) &#123; if (is_array($values)) &#123; $v[$key] = implode('|', $values); &#125; (string)$v[$key]; &#125; $exportData = implode(',', $v); $exportData = $exportData . \"\\r\\n\"; $myfile = fopen(\"data.csv\", \"a\") or die(\"Unable to open file!\"); $this-&gt;writeToCsvFile($data, $myfile, $exportData); fclose($myfile); &#125; &#125; function writeToCsvFile(array $data, $myfile, $exportData) &#123;// $txt = \\GuzzleHttp\\json_encode($data); fwrite($myfile, $exportData); return true; &#125;?&gt;","categories":[{"name":"有用代码段收集","slug":"有用代码段收集","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%89%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"运行相关","slug":"codeCollect2","date":"2020-02-25T12:10:10.000Z","updated":"2020-07-09T03:18:14.201Z","comments":true,"path":"2020/02/25/codeCollect2/","link":"","permalink":"http://www.hexiaojiao.top/2020/02/25/codeCollect2/","excerpt":"","text":"1 下载数据描述根据链接下载文件代码 1234567891011121314151617&lt;?php function downloadOldFile($url,$rename,$ext)&#123; $file_path = 'public/images/age_60-120/'; $ch = curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_BINARYTRANSFER, 1); $rawdata=curl_exec ($ch); curl_close ($ch); // 使用中文文件名需要转码 $fp = fopen($file_path. $rename .\".\".$ext,'w'); fwrite($fp, $rawdata); fclose($fp); // 返回路径 return $_SERVER['DOCUMENT_ROOT'].$file_path.$rename.\".\".$ext;&#125;?&gt; 2 按步骤执行方法描述经常有需求：分页执行脚本，例如前1000条执行完后继续分页，此时就需要自动跳页执行代码 ```php&lt;?php /** * @param mixed …$args * @return bool * @throws Exception */ private function stepRun(…$args) { $count = $args[0]; $method = $args[1]; $step = array_key_exists(2, $args) ? $args[2] : 10; $limit = array_key_exists(3, $args) ? $args[3] : 10; $param = array_key_exists(4, $args) ? $args[4] : ‘’; $stepCount = ceil($count / $step); for ($nowStep = 0; $nowStep &lt; $stepCount; $nowStep ++) { $this-&gt;$method($limit, $nowStep * $step, $param); sleep(1); } sleep(1); return true; } // 调用 // $this-&gt;stepRun($exportCount, ‘loopChildData’, 1000, $ageId); // 执行方法 /** function loopChildData(int $limit = 1000, int $skip = 0, string $ageId = &apos;&apos;) { $data = $this-&gt;dao-&gt;conn-&gt;query([&apos;faceItems&apos; =&gt; [&apos;$in&apos; =&gt; [$ageId]], &apos;status&apos; =&gt; 2, &apos;apiCheckPass&apos; =&gt; true], null, [&apos;limit&apos; =&gt; $limit, &apos;skip&apos; =&gt; $skip]); foreach ($data as $v) { $this-&gt;downloadChildFile(Url::createPrivateUrl($v[&apos;url&apos;]), $v[&apos;_id&apos;], &apos;jpg&apos;); } } **/?&gt;``","categories":[{"name":"有用代码段收集","slug":"有用代码段收集","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%89%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"有用的代码段-ts篇","slug":"usefulCode2","date":"2020-01-16T11:34:10.000Z","updated":"2020-07-09T03:26:11.135Z","comments":true,"path":"2020/01/16/usefulCode2/","link":"","permalink":"http://www.hexiaojiao.top/2020/01/16/usefulCode2/","excerpt":"","text":"查询数组中值相等的1modules.modules.find(item =&gt; item.route === route).chinese ref调用子组件1&lt;FacePointsMarkTool ref=&#123;com =&gt; this.com = com&#125; customRightRender=&#123;this.customRightRender&#125; hideSaved=&#123;this.handleHideSaved&#125; dataSource=&#123;dataSource&#125; loadMore=&#123;this.getFaceData&#125; isShowFacePlus saveFaceData=&#123;this.saveFaceData&#125;&gt;&lt;/FacePointsMarkTool&gt;","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://www.hexiaojiao.top/tags/tips/"}]},{"title":"有用的代码段-php篇","slug":"usefulCode1","date":"2020-01-16T04:34:10.000Z","updated":"2020-07-09T03:26:04.515Z","comments":true,"path":"2020/01/16/usefulCode1/","link":"","permalink":"http://www.hexiaojiao.top/2020/01/16/usefulCode1/","excerpt":"","text":"分步骤执行12345678910111213141516171819202122&lt;?php/** * @param mixed ...$args * @return bool * @throws Exception */public function stepRun(...$args): bool&#123; $count = $args[0]; $method = $args[1]; $step = array_key_exists(2, $args) ? $args[2] : 10; $limit = array_key_exists(3, $args) ? $args[3] : 10; $param = array_key_exists(4, $args) ? $args[4] : ''; $stepCount = ceil($count / $step); for ($nowStep = 0; $nowStep &lt; $stepCount; $nowStep ++) &#123; $this-&gt;$method($limit, $nowStep * $step, $param); sleep(1); &#125; sleep(1); return true;&#125;?&gt; 使用方法123&lt;?php$this-&gt;stepRun($groupChangeCount, 'loopGetData', 30, 30);?&gt; 分析可运用于需要遍历数据库数据，对数据执行操作的功能上。 mongodb查询12345678910111213141516171819202122&lt;?php/** 宜宾爱你宝贝 * @return bool|int * @throws \\yii\\base\\InvalidConfigException */public function checkAssign()&#123; $query = [ '$or' =&gt; [ ['isMarked' =&gt; false], ['isMarked' =&gt; ['$exists' =&gt; false]] ], 'faceChecked' =&gt; true, 'assignAuthor' =&gt; BackendCookieHelper::getName()]; if ($this-&gt;dao-&gt;conn-&gt;count($query) &gt;= 20) &#123; return true; &#125; else &#123; unset($query['assignAuthor']); return $this-&gt;assignToPerson($query); &#125;&#125;?&gt;","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://www.hexiaojiao.top/tags/tips/"}]},{"title":"测试","slug":"unitTest","date":"2019-12-10T04:34:10.000Z","updated":"2020-07-09T03:25:14.465Z","comments":true,"path":"2019/12/10/unitTest/","link":"","permalink":"http://www.hexiaojiao.top/2019/12/10/unitTest/","excerpt":"","text":"单元测试mock接口测试stubmockfakeserver","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"测试","slug":"学习/测试","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.hexiaojiao.top/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"使用go编写webassembly","slug":"webassembly_go_1","date":"2019-12-10T04:34:10.000Z","updated":"2020-07-09T03:27:57.836Z","comments":true,"path":"2019/12/10/webassembly_go_1/","link":"","permalink":"http://www.hexiaojiao.top/2019/12/10/webassembly_go_1/","excerpt":"","text":"使用go编写webassembly并在浏览器执行参考博客用go写WebAssembly入门 下载安装go 编写测试文件hello.go1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello World!&quot;)&#125; 生成wasm文件1在windows下需要先设置环境变量：&#96;&#96;&#96; $env:GOARCH&#x3D;&quot;wasm&quot;;$env:GOOS&#x3D;&quot;js&quot;; 添加依赖1cp $(go env GOROOT)&#x2F;misc&#x2F;wasm&#x2F;wasm_exec.&#123;html,js&#125; . 添加一个测试http服务器1234567891011121314151617181920212223242526&#x2F;&#x2F;http.gopackage mainimport ( &quot;flag&quot; &quot;log&quot; &quot;net&#x2F;http&quot; &quot;strings&quot;)var ( listen &#x3D; flag.String(&quot;listen&quot;, &quot;:8080&quot;, &quot;listen address&quot;) dir &#x3D; flag.String(&quot;dir&quot;, &quot;.&quot;, &quot;directory to serve&quot;))func main() &#123; flag.Parse() log.Printf(&quot;listening on %q...&quot;, *listen) log.Fatal(http.ListenAndServe(*listen, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) &#123; if strings.HasSuffix(req.URL.Path, &quot;.wasm&quot;) &#123; resp.Header().Set(&quot;content-type&quot;, &quot;application&#x2F;wasm&quot;) &#125; http.FileServer(http.Dir(*dir)).ServeHTTP(resp, req) &#125;)))&#125; 执行go run http.go 查看效果浏览器打开http://localhost:8080/wasm_exec.html，点击run，控制台可以看到效果 node执行1node wasm_exec.js test.wasm","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.hexiaojiao.top/tags/go/"}]},{"title":"单例模式","slug":"design_singleton","date":"2019-10-29T09:40:10.000Z","updated":"2020-07-09T03:23:44.859Z","comments":true,"path":"2019/10/29/design_singleton/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/29/design_singleton/","excerpt":"","text":"概念介绍情景介绍一个类只需要被实例化一次，但是不应该由调用方来判断是否被实例化过 基础介绍所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。类把构造方法设置为私有，使所有的方法都不能直接实例化这个类。然后类内部写一个公共方法来判断这个类是否被实例化过，调用方无需判断 单例模式单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。通常可以让一个全局变量使得一个对象被访问，但它不能防止实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.hexiaojiao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"react学习-Props,state和组件树","slug":"react_06","date":"2019-10-22T10:37:10.000Z","updated":"2020-07-08T11:28:40.338Z","comments":true,"path":"2019/10/22/react_06/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/22/react_06/","excerpt":"","text":"react学习手册属性验证javascript是弱类型语言，可更改变量的类型，难以查找类型错误。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[]},{"title":"react学习-基础","slug":"react_base","date":"2019-10-22T10:37:10.000Z","updated":"2020-07-08T11:28:40.338Z","comments":true,"path":"2019/10/22/react_base/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/22/react_base/","excerpt":"","text":"相关概念介绍reactES6DOMReduxreact-routewebpack","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[]},{"title":"mongodb学习记录","slug":"mongoComplex","date":"2019-10-20T10:27:44.000Z","updated":"2020-07-08T11:28:40.336Z","comments":true,"path":"2019/10/20/mongoComplex/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/20/mongoComplex/","excerpt":"","text":"参考文档http://www.mongoing.com/docs/reference/operator/aggregation/interface.htmlhttps://www.cnblogs.com/zhoujie/p/mongo1.htmlhttps://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/tutorial-text-search-in-aggregation.html mongodb精准匹配假设有需求如下：数据为多层级的数组，需要精准匹配到某一个层级，并进行更新或新增等操作，如何实现？ 实现方式当Mongodb版本大于3.6.1，实现将会非常简单，因为mongodb3.6.1以上可以直接通过语句来实现精准匹配。但由于实际场景中版本不支持，当匹配超过一级则会报错：Too many positional (i.e. ‘$’) elements found in path ‘files.$.testConstruct.params.list.$.testRange’当版本大于3.6.1，举例： 123db.test_db.update( &#123;&#39;_id&#39;: &#123;$in: [&#39;1242rererwwr&#39;]&#125;, &#39;files.name&#39;: &#39;test1.json&#39;, &#39;files.testConstruct.params.list.type&#39;: &#39;NewData&#39;&#125;, &#123;$set: &#123;&#39;files.$.structuredContent.params.list.$.testRange&#39;: &#123;&#39;enable&#39;: false, &#39;min&#39;: 14, &#39;max&#39;: 90&#125;&#125;, $currentDate: &#123; updatedDatetime: true &#125;&#125;, &#123; multi: true &#125;) 分析：设置值时，’files.$.testConstruct.params.list.$.testRange’中的第一个”$”将会匹配到name=test1.json的数组，第二个”$”将会匹配到files.structuredContent.params.list.type=NewData的数组优点： 使用简单，匹配精确，无需代码判断缺点： 适用版本有限制，且由于多级匹配需要更多的条件，而实际业务中不一定能取到这些条件（例如知道要更新的key为testRange但是不知道上级查询条件无法匹配到）如果版本过低，可只匹配第一级，其余的通过代码匹配。当版本小于3.6.1举例： 12345678910111213141516&lt;?phppublic function batchUpdateContents(string $route, array $ids, string $editor, $updateItems, bool $needPublish): bool &#123; $routes = explode('-', $route); array_shift($routes); $routes[2] = self::TYPE_LIST[$routes[2]]; $updateRoute = 'files.$.testConstruct.' . implode('.', $routes); $res = $this-&gt;conn-&gt;update(['storeId' =&gt; ['$in' =&gt; $ids], 'files.name' =&gt; 'makeup.json', 'files.testConstruct' =&gt; ['$ne' =&gt; '']], ['$set' =&gt; [$updateRoute =&gt; $updateItems, 'files.$.editor' =&gt; $editor, 'files.$.lastUpdate' =&gt; time()], '$currentDate' =&gt; [ 'updatedDatetime' =&gt; true ]], true); if ($res) &#123; // 一些其他操作 &#125; else &#123; return false; &#125; &#125;?&gt; 枚举出可能存在的下一级数组值，然后进行匹配。update()方法当参数不存在时会进行新增参数操作。 mongodb聚合mongodb的聚合操作可对数据进行一系列操作并返回结果。mongodb提供三种聚合操作：aggregation pipeline, map-reduce方法和分片集合 aggregation pipeline管道操作，基础操作为筛选操作，其他操作：可通过特定的字段来进行分组和排序等 $project类似于sql的select，筛选出需要查询的字段，例如：{$project: {‘name’: 1, ‘age’:1}},也可以排除字段（0）,重命名字段，派生字段（1）: &lt;1 or true&gt; 是否包含该字段，field:1/0，表示选择/不选择 field（2）:&lt;0 or false&gt; v3.4新增功能，指定排除字段（3）: 添加新字段或重置现有字段的值。 在版本3.6中更改：MongoDB 3.6添加变量REMOVE。如果表达式的计算结果为$$REMOVE，则该字段将排除在输出中。3.6可使用变量REMOVE来有条件地禁止一个字段： 12345678910111213141516db.books.aggregate( [ &#123; $project: &#123; title: 1, &quot;author.first&quot;: 1, &quot;author.last&quot; : 1, &quot;author.middle&quot;: &#123; $cond: &#123; if: &#123; $eq: [ &quot;&quot;, &quot;$author.middle&quot; ] &#125;, then: &quot;$$REMOVE&quot;, else: &quot;$author.middle&quot; &#125; &#125; &#125; &#125;] ) 使用$project派生举例123456789101112131415161718db.books.aggregate( [ &#123; $project: &#123; title: 1, isbn: &#123; prefix: &#123; $substr: [ &quot;$isbn&quot;, 0, 3 ] &#125;, group: &#123; $substr: [ &quot;$isbn&quot;, 3, 2 ] &#125;, publisher: &#123; $substr: [ &quot;$isbn&quot;, 5, 4 ] &#125;, title: &#123; $substr: [ &quot;$isbn&quot;, 9, 3 ] &#125;, checkDigit: &#123; $substr: [ &quot;$isbn&quot;, 12, 1] &#125; &#125;, lastName: &quot;$author.last&quot;, copiesSold: &quot;$copies&quot; &#125; &#125; ]) 投影出新数组：示例数据： 1&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;x&quot; : 1, &quot;y&quot; : 1 &#125; 操作： 1db.collection.aggregate( [ &#123; $project: &#123; myArray: [ &quot;$x&quot;, &quot;$y&quot; ] &#125; &#125; ] ) 返回： 1&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;myArray&quot; : [ 1, 1 ] &#125; 如果返回的数组中包含了不存在的字段，则会返回null $match类似于sql中的where，设置查询条件，例如：{$match: {‘name’: {‘$ne’: ‘’}}}$match仅接受一个指定查询条件的文档，查询语法与读操作查询语法相同。 语法{$match: {}} 注意事项在实际应用中尽可能将$match放在管道的前面位置。这样有两个好处：一是可以快速将不需要的文档过滤掉，以减少管道的工作量；二是如果再投射和分组之前执行$match，查询可以使用索引。 限制条件（1）不能在$match查询中使用$作为聚合管道的一部分（2）要在$match阶段使用$text，$match阶段必须是管道的第一阶段 查询条件介绍$gt:大于$lt:小于$gte:大于等于$lte:小于等于$in:类似于sql中的in$nin:不在该范围内的键$or:包含多个可能的条件 $limit限制传递到管道中下一阶段的文档数 skip跳过指定数量的文档，并将其余文档传递到管道中的下一阶段 $unwind从输入文档解构数组字段以输出每个元素的文档，即：将数组拆分成单独的文档 举例123456789101112&#123; $unwind: &#123; path: &lt;field path&gt;, includeArrayIndex: &lt;string&gt;, #可选,一个新字段的名称用于存放元素的数组索引。该名称不能以$开头。 preserveNullAndEmptyArrays: &lt;boolean&gt; #可选，default :false，若为true,如果路径为空，缺少或为空数组，则$unwind输出文档 &#125; &#125;db.getCollection(&#39;test&#39;).aggregate( [ &#123; $unwind : &quot;$sizes&quot; &#125; ]) $group释义按指定的表达式对文档进行分组，并将每个不同分组的文档输出到下一个阶段。输出文档包含一个_id字段，该字段按键包含不同的组。 输出文档还可以包含计算字段，该字段保存由$group的_id字段分组的一些accumulator表达式的值。 $group不会输出具体的文档而只是统计信息。 语法{ $group: { _id: , : { : }, … } }解析：_id字段必填，可以指定为null，表示为整个输入文档计算累计值，剩余的计算字段是可选的，并使用运算符进行计算。 accumulator操作符 名称 描述 类比sql $avg 计算均值 avg $first 返回每组第一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的第一个文档。 limit 0,1 $last 返回每组最后一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的最后个文档。 - $max 根据分组，获取集合中所有文档对应值得最大值。 max $min 根据分组，获取集合中所有文档对应值得最小值。 min $push 将指定的表达式的值添加到一个数组中。 - $addToSet 将表达式的值添加到一个集合中（无重复值，无序）。 - $sum 计算总和 sum $stdDevPop 返回输入值的总体标准偏差（population standard deviation） - $stdDevSamp 返回输入值的样本标准偏差（the sample standard deviation） - 注意事项（1）$group阶段的内存限制为100M，默认情况下，如果stage超过此限制，$group将产生错误，但是，要允许处理大型数据集，需要将allowDiskUse选项设置为true以启用$group操作写入临时文件（2）”$addToSet”: expr如果当前数组中不包含expr，那就将它添加到数组中（3）”$push”:expr，不管expr的值，都将它添加到数组中，返回包含所有值的数组。 举例12345678910db.getCollection(&#39;test&#39;).aggregate([ &#123; $group: &#123; _id: &#123;month: &#123;$month: &quot;$data&quot;&#125;, day: &#123;$dayOfMonth: &quot;$date&quot;, year: &#123; $year: &quot;$date&quot;&#125;&#125;&#125;, totalPrice: &#123;$sum: &#123;$multiply: [&quot;$price&quot;, &quot;$quantity&quot;]&#125;&#125;, averageQuantity: &#123;$avg: &quot;$quantitu&quot;&#125;, count: &#123;$sum: 1&#125; &#125; &#125;]) 数据转换（1）可以根据分组把每组转换成item数组 1db.getCollection(&#39;test&#39;).aggregate([&#123;$group: &#123;_id: &#39;$price&#39;, items: &#123;$pish: &quot;$item&quot;&#125;&#125;&#125;]) 返回值： 1&#123;[&quot;_id&quot;: 5, &quot;items&quot;: [&quot;abc&quot;, &quot;abc&quot;]]&#125; (2) 可以使用系统变量$$ROOT按item对文档进行分组，生成的文档不得超过BSON文档大小限制 1db.getCollection(&#39;test&#39;).aggregate([&#123;$group: &#123;_id: &quot;$item&quot;, books: &#123;$push: &quot;$$ROOT&quot;&#125;&#125;&#125;]) 返回值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;* 1 *&#x2F;&#123; &quot;_id&quot; : &quot;xyz&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00.000Z&quot;) &#125;, &#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) &#125; ]&#125;&#x2F;* 2 *&#x2F;&#123; &quot;_id&quot; : &quot;jkl&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00.000Z&quot;) &#125; ]&#125;&#x2F;* 3 *&#x2F;&#123; &quot;_id&quot; : &quot;abc&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00.000Z&quot;) &#125;, &#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) &#125; ]&#125; count返回包含到输出文档的计数 sort对文档进行排序，按照排序顺序返回管道。1:升序排列-1:降序排列{$meta：“textScore”}按照降序排列计算出的textScore元数据，表达方式唯一，尽管可以在管道中接受表达式，但{ $meta: “textScore” }表达式仅在包含具有$text查询的$match阶段的管道中有意义。分析：$text文本搜索，会为包含索引字段中的搜索词的每隔文档匹配一个分数，这个分数表示文档与给定文本搜索查询的相关性举例： 123456db.users.aggregate( [ &#123; $match: &#123; $text: &#123; $search: &quot;operating&quot; &#125; &#125; &#125;, &#123; $sort: &#123; score: &#123; $meta: &quot;textScore&quot; &#125;, posts: -1 &#125; &#125; ]) $sortByCountv3.4新增，根据表达式的值对传入文档分组，计算每个不同组中文档的数量，每个输出文档都包含两个字段：包含不同分组值得_id字段和包含属于该分组或类别的文档数的计数字段，文件按降序排列举例： 1db.db_test.aggregate(&#123;$sortByCount: &#39;$status&#39;&#125;); geoNearlookupmongodb在大部分情况下是不需要连表的，但是依然支持连表操作，即:$lookUp outindexStats索引mongodb正则匹配mongodb连接方式mongodb://[username:password@]host1[:port1][,host2[:port2],…[,hostN[:portN]]][/[database][?options]] mongodb查看版本mongod –version","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongodb","slug":"数据库/mongodb","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"}],"tags":[]},{"title":"代码整洁之道1-9章","slug":"cleanCode","date":"2019-10-07T09:40:10.000Z","updated":"2020-07-09T03:15:23.791Z","comments":true,"path":"2019/10/07/cleanCode/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/07/cleanCode/","excerpt":"","text":"提要要有代码：代码呈现了需求的细节，将需求明确到机器可以执行的细节程度不要产生糟糕的、混乱的代码，勒布朗法则：稍后等于永不制造混乱无益于赶上期限，做得快的唯一方法就是始终保持代码整洁。 好代码的特点优雅、搞笑；代码逻辑直截了当，缺陷难以隐藏；尽量减少依赖关系，使之便于维护；根据某种分层战略完善处理错误代码，性能调至最优整洁的代码力求集中，每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染整洁的代码可由作者之外的开发者阅读和增补，它应当有单元测试和验收测试尽量使用有意义的命名，它只提供一种而非多种做一件事的途径尽量少的依赖关系，明确地定义和提供清晰、尽量少的API 总结（1）能通过所有测试（2）没有重复代码（3）体现系统中的全部设计理念（4）包含尽量少的实体，比如类、方法、函数等不要重复代码，只做一件事，表达力，小规模抽象 有意义的命名（1）如果名称需要注释来补充，那就不算是名副其实（之前出现过争议）（2）不要使用意义含糊的废话，如果名称相同但是意义不同，那么info和data与a an the一样毫无意义，不要使用废话，varable不应出现在便能两种，table不应出现在表中（3）使用读得出来的名称，方便阅读（4）使用方便搜索的名称（5）避免使用编码（6）应当把类和函数做得足够小，消除对成员前缀的需要，读代码的人通常不会读前缀（7）不要在类名中使用奇怪的命名（8）不要使用双关语 函数（1）函数应该尽可能小，20行封顶最佳（2）每个函数都一目了然，每个函数都只说一件事，每个函数都依次带到下一个函数（3）函数的缩进层不应该多余一层或两层 需要遵循的原则（1）确保每隔switch函数都埋藏在较低的抽象层而且永远不重复（2）不要向函数传入布尔值（我以前经常这么做），因为传入布尔值表示函数会有多余的操作（3）使用异常代替返回错误码（错误代码能从主路径代码中分离出来得到简化）（4）抽离try/catch代码块（5）不要重复自己 注释注意注释存在的时间越久，就离它所描述的代码越远，越来越变得全然错误，因为程序员不能坚持维护注释 必要的注释（好的注释）（1）法律信息（2）提供信息的注释（3）对意图的解释（4）阐释（如果参数或返回值是某个标准库的一部分或者不能修改的代码，帮助阐释其含义的代码就会有用）（5）警示 单元测试","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"代码整洁之道","slug":"学习/代码整洁之道","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"设计模式六大原则","slug":"codePrinceple","date":"2019-10-07T09:40:10.000Z","updated":"2020-07-09T03:15:15.900Z","comments":true,"path":"2019/10/07/codePrinceple/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/07/codePrinceple/","excerpt":"","text":"##第一：单一职责原则（SPR）一个类应该有且仅有一个原因导致该类的变更，即一个类应该只负责一项职责##第二：里氏替换原则（LSP） ##第三：依赖倒置原则（DIP）抽象不应该依赖细节，细节应该依赖于抽象。针对接口编程，不要针对实现编程##第四：接口隔离原则（ISP）##第五：迪米特法则（LoD）##第六：开放封闭原则开放-封闭原则是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"单例模式","slug":"singleMode","date":"2019-10-06T02:40:10.000Z","updated":"2020-07-09T03:19:23.870Z","comments":true,"path":"2019/10/06/singleMode/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/06/singleMode/","excerpt":"","text":"基础介绍概念介绍作为对象的创建模式，单例模式确保某一个类只有一个实例，并且对外提供这个全局实例的访问入口。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。 单例模式三要素 需要一个保存类的唯一实例的静态成员变量。 构造函数和克隆函数必须声明为私有的，防止外部程序创建或复制实例副本。 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用。","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"生产者消费者模式","slug":"producerConsumer","date":"2019-10-05T09:40:10.000Z","updated":"2020-07-09T03:22:49.827Z","comments":true,"path":"2019/10/05/producerConsumer/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/05/producerConsumer/","excerpt":"","text":"基础概念概念介绍某块模块负责产生数据，这些数据由另一个模块来负责处理。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据缓冲区作用 解耦，生产者和消费者只依赖缓冲区，而不互相依赖 支持并发和异步 支持生产者和消费者忙闲不均（来不及消费缓冲区可以暂存） 使用场景队列(类似，但并不完全相等，有的队列没有缓冲区);swoole(业务逻辑(生产者)将数据单元通过swoole的send函数弄到swoole的一个缓冲区之间，通过work进程进行分发，task进程(消费者)进行消费。) 代码解析CICD创建项目流程类似于生产者消费者模式；（1）用户填写表单，创建一条CICD数据，生产者向数据表添加一条状态为pending的数据，类似于向缓冲区添加数据（2）定时任务读取状态为pending的数据，消费处理后修改状态","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"工作经验总结","slug":"work","date":"2019-10-05T09:40:10.000Z","updated":"2020-07-09T03:21:22.732Z","comments":true,"path":"2019/10/05/work/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/05/work/","excerpt":"","text":"工作经验（1）学会控制情绪","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"代码大全","slug":"codeComplate_01","date":"2019-10-05T02:40:10.000Z","updated":"2020-07-09T03:18:03.390Z","comments":true,"path":"2019/10/05/codeComplate_01/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/05/codeComplate_01/","excerpt":"","text":"前期准备前期准备的重要性不要立即开始写代码，要做好必要的需求分析和架构设计，写好需求文档和技术文档，防止浪费时间和精力制造错误的东西 需求核对表针对功能需求： 1．是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？ 2．是否详细定义了系统的全部输出，包括其目的地、精度、取值范围、出现频率格式等？ 3．是否详细定义了所有的输出格式(如：web页面、报表等)？ 4．是否详细定义了所有硬件及软件的外部接口？ 5．是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？ 6．是否列出了用户所要做的全部事情？ 7．是否详细定义了每个任务所用数据，以及每个任务得到的数据 针对非功能需求（质量需求） 1.是否为全部必要的操作，从用户的角度，详细描述的期望的响应时间 ？ 2.是否详细描述了其他与计时有关的考虑，如处理时间、数据传输率、系统吞吐量等？ 3.是否详细定义了安全级别 4.是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检查与回复的策略等？ 5.是否详细定义了机器内存和剩余硬盘空间最小值？ 6.是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口变更的能力？ 7.是否包含对“成功”的定义，“失败”的定义？ 需求的质量 需求是用户书写的吗？ 每条需求都不与其他需求冲突吗？ 是否详细定义了相互竞争的特性之间的权衡 是否避免在需求中规定设计(方案) 需求是否在详细程度上保持相当一致的水平？有些需求应当更详细的描述吗？有些需求应该更粗略的描述吗？ 需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也这么想吗？ 每个条款都与待解决的问题及解决方案相关吗？能从每个条款上溯到它的问题中的对应跟源吗？ 是否每条需求都是可测试的？是否可应进行独立的测试，以检验满不满足各项需求 是否描述了所有可能对需求的改动，包括各项改动的可能性 需求的完备性 1.对于在开始开发之前无法获得信息，是否详细描述了信息不完全的区域？ 2.需求的完备度是否达到这种程度：如果产品满足所有需求，那么它就是可接受的？ 3.你对全部需求都感觉舒服吗？你是否已经去掉了那些不可能完成的需求—那些只是为了安抚客户和老板的东西？ 花费在前期准备上的时间长度花费在问题定义，需求分析，软件架构上的时间依据项目的需要而变化，一般占据10%-20%的工作量和20%-30%的时间 良好的类接口类的基础是抽象数据类型（我之前大部分时候没有使用抽象，只是把相关的方法和变量定义放在了一起，实际上是不符合面向对象变成原则的），抽象数据类型是指一些数据和对这些数据所进行操作的集合。定义抽象类有助于代码规范，提高 创建类的原因（1）为显示世界中的对象建模（2）为抽象的对象建模（3）降低复杂度（4）隔离复杂度（5）隐藏实现细节（6）让代码更易重用（7）把相关的操作包装到一起 应当避免的类（1）避免创建万能类（2）消除无关紧要的类（3）避免用动词命名的类 防御式编程三种处理进入垃圾的情况（1）检查所有来源于外部的数据的值（2）检查所有子程序输入参数的值（3）决定如何处理错误的输入数据 断言断言是指在开发期间使用的、让程序在运行时进行自检的代码 异常用异常通知程序的其他部分发生了不可忽略的错误只有真正例外的情况下才抛出异常不能用异常来推卸责任避免在构造函数和析构函数中抛出异常，除非在同一地方把他们捕获在恰当的抽象层次抛出异常 变量与《代码整洁之道》对变量的要求几乎一致 代码改善软件质量的特性外在特性：（1）正确性：指系统规范、设计和实现方面的错误的稀少程度（2）可用性：指用户学习和使用一个系统的容易程度（3）效率：指软件是否尽可能少地占用系统资源，包括内存和执行时间（4）可靠性：指在制定的必须条件下，一个系统完成所需要功能的能力-应该有很长的平均无故障时间（5）完整性：限制、验证（6）适应性：适应不同执行环境（7）精确性：输出结果的精确程度（8）健壮性：系统在接受无效输入或处于压力环境下持续正常运行的能力内在特性：（1）可维护性：指很容易能够对系统进行修改或新增功能，提高性能及修正缺陷（2）灵活性：系统适用其他系统或者修改难易程度（3）可移植性：运行环境的可移植性（4）可重用性：指系统的某些部分可被应用到其他系统的难易程度（5）可读性：指阅读或理解系统代码的难易程度，尤其是在细节语句的层次上（6）可测试性：指的是可以进行何种程度的单元测试或者系统测试，以及在何种程度上验证系统是否符合需求（7）可理解性：指在系统组织和细节语句的层次上理解整个系统的难易程度 协同构建开发者测试调试重构软件工艺布局与风格","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"代码大全","slug":"学习/代码大全","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"命令模式","slug":"commandMode","date":"2019-10-04T09:40:10.000Z","updated":"2020-07-09T03:23:12.430Z","comments":true,"path":"2019/10/04/commandMode/","link":"","permalink":"http://www.hexiaojiao.top/2019/10/04/commandMode/","excerpt":"","text":"基础概念基础介绍（1）概念介绍：命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。（2）概念解析：命令模式将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 使用场景在某些场合下，需要对行为进行”记录、撤销/重做、事务”等处理，需要将”行为请求者”与”行为实现者”解耦，将一组行为抽象为对象，可以实现二者之间的松耦合。认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 关键术语（1）received：真正的命令执行对象（2）Command：命令（3）invoker：使用命令对象的入口 实现步骤以下以后台k8s删除node节点命令为例 a.创建一个命令接口：接口定义接口名称，需要实现的操作名称，命令模式需要的操作为执行命令，后续可根据不同的命令来实现这个接口和执行命令方法。 12345&lt;?phpabstract class Nodes &#123; public function execute()&#123;&#125;&#125;?&gt; b.创建一个请求类定义拥有的请求方法本例中操作有：（1）列出所有nodes: kubectl get node（2）删除节点：kubectl delete node $nodeName（3）查看对应node上的pods信息: kubectl get pods -o wide | grep $nodeName（4）在删除的node3对应的服务器上执行：kubeadm reset 123456789101112&lt;?phpclass K8s &#123; public function getNodes() &#123; return 'kubectl get node'; &#125; public function delNodes($nodeName) &#123; return \"kubectl delete node $nodeName \"; &#125;&#125;?&gt; c.创建实现接口的实体类针对不同的方法实现命令接口。即实现a步骤（创建一个命令接口）所创建的接口，b中的每个请求方法都需要实现对应的实体类。 123456789101112131415161718192021222324252627282930&lt;?phpclass GetNodes implements Nodes &#123; private $nodes = new K8s(); public function getK8s():K8s &#123; if (empty($this-&gt;nodes)) &#123; $this-&gt;nodes = new K8s(); &#125; return $this-&gt;nodes; &#125; public function execute() &#123; $this-&gt;getK8s()-&gt;getNodes(); &#125;&#125;class DelNodes implements Nodes &#123; private $nodes = new K8s(); public function getK8s():K8s &#123; if (empty($this-&gt;nodes)) &#123; $this-&gt;nodes = new K8s(); &#125; return $this-&gt;nodes; &#125; public function execute() &#123; $this-&gt;getK8s()-&gt;delNodes(); &#125;&#125;?&gt; 创建命令调用类broker,用来调用命令 123456789101112131415&lt;?phpclass Broker&#123; private $commandList = []; public function addList($k8s) &#123; array_push($this-&gt;commandList, $k8s); &#125; public function executeList() &#123; foreach ($this-&gt;commandList as $command) &#123; $command-&gt;execute(); &#125; &#125;&#125;?&gt; 使用broker类来接受并执行命令调用broker类，根据需要（顺序，需要使用的方法等）添加一个执行队列（数组），之后再执行 12345678910111213141516&lt;?phpclass CommandUse&#123; public function executeCommand() &#123; $getNodes = new GetNodes(); $delNodes = new DeleNodes(); $broker = new Broker(); $broker-&gt;addList($getNodes); $broker-&gt;addList($delNodes); $broker-&gt;executeList(); &#125;&#125;?&gt; 执行程序输出结果命令模式的优点（1）比较容易设计出一个命令队列（2）在需要的情况下，可以比较容易的将命令记入日志（3）允许接收请求的一方决定是否要否决请求（4）可以容易地实现对请求的撤销和重做（5）由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易（6）命令模式把请求一个操作的对象和知道怎么执行一个操作的对象分割开","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"生成json映射表","slug":"json","date":"2019-08-15T02:27:44.000Z","updated":"2020-07-08T11:28:40.335Z","comments":true,"path":"2019/08/15/json/","link":"","permalink":"http://www.hexiaojiao.top/2019/08/15/json/","excerpt":"","text":"生成json映射表代码12345678910111213141516171819202122232425262728&lt;?php$dic = [ 'qd' =&gt; [...], 'mp' =&gt; [... 100], 'jl' =&gt; [...], 'sb' =&gt; [..., 50, 60, 70, 85, 100], 'ly' =&gt; [..., 50, 60, 70, 85, 100], 'dy' =&gt; [...0, 50, 60, 70, 85, 100], 'sl' =&gt; [...55, 60, 65, 70, 85, 100], 'xl' =&gt; [... 50, 55, 65, 75, 85, 100], 'vl' =&gt; [...50, 60, 70, 80, 90, 100], 'rh' =&gt; [... 100] ];function getJson($dic) &#123; $res = [];foreach($dic as $k =&gt; $v)&#123; $res[$k] = []; foreach($v as $key =&gt; $val) &#123; $res[$k]['mapV'][$key] = [ 'label' =&gt; (string)$key, 'value' =&gt; (string)$val];&#125;&#125;var_dump(json_encode($res));&#125;getJSON($dic);?&gt;","categories":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]},{"title":"策略模式","slug":"Strategy","date":"2019-07-29T06:37:10.000Z","updated":"2020-07-09T03:23:04.438Z","comments":true,"path":"2019/07/29/Strategy/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/29/Strategy/","excerpt":"","text":"概念定义策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，该模式让算法独立于使用它的客户而独立变化 组成1 抽象策略角色：策略类，通常由一个接口或者抽象类实现2 具体策略角色：包装了相关的算法和行为。3 环境角色：持有一个策略类的引用，最终给客户端调用。 分析策略模式用一个抽象策略角色提供一个类（一般是接口或抽象类），每个策略都实现了这个抽象策略角色，环境角色去调用（依赖注入） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?php/** * @author: hexiaojiao@jiapinai.com * @todo: * time: 2019-07-30 20:07 *//** * 定义抽象角色类` * Interface CollectInter */interface CollectInter&#123; public function collect($price, $num); public function input();&#125;class Base&#123; public function input($discount = 1) &#123; fwrite(STDOUT, '请输入单价'); $price = trim(fgets(STDIN)); fwrite(STDOUT, '请输入数量'); $num = trim(fgets(STDIN)); $res = $this-&gt;collect($price, $num, $discount); return $res; &#125;&#125;/** * 定义具体策略类 * Class Collect02 */class Collect02 extends Base implements CollectInter&#123; public function collect($price, $num, $discount = 1) &#123; var_dump('Collect02:', $price * $num * $discount); return true; &#125;&#125;/** * Class Discount */class Discount extends Base implements CollectInter&#123; public function collect($price, $num, $discount = 0.8) &#123; var_dump('Discount:', $price * $num * $discount); return true; &#125;&#125;/** * Class Reduce */class Reduce extends Base implements CollectInter&#123; public function collect($price, $num, $total = 100, $reduce = 0) &#123; if ($price * $total &gt;= $total) &#123; var_dump('Reduce:', ($price * $total) - $reduce); &#125; else &#123; var_dump('Reduce:', $price * $total); &#125; return true; &#125;&#125;/** * 环境角色类 * Class Main */class Main&#123; private $_strategy; private $_isChange; public function __construct(CollectInter $collectInter) &#123; $this-&gt;_strategy = $collectInter; &#125; public function change(CollectInter $collectInter) &#123; $this-&gt;_strategy = $collectInter; $this-&gt;_isChange = true; &#125; public function beginCollect() &#123; if ($this-&gt;_isChange) &#123; echo \"改变收银方式：\"; $this-&gt;_strategy-&gt;input(); &#125; else &#123; $this-&gt;_strategy-&gt;input(); &#125; &#125;&#125;$strategy = new Main(new Discount());$strategy-&gt;beginCollect();$strategy-&gt;change(new Collect02());$strategy-&gt;beginCollect(); 运行结果12345678请输入单价4请输入数量2string(9) &quot;Discount:&quot;int(8)改变收银方式：请输入单价7请输入数量3string(10) &quot;Collect02:&quot;int(21)","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"react单元测试","slug":"reactUnit","date":"2019-07-29T02:40:10.000Z","updated":"2020-07-09T03:19:11.552Z","comments":true,"path":"2019/07/29/reactUnit/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/29/reactUnit/","excerpt":"","text":"测试ESLint代码检查（分析JavaScript代码）,JSHint和JSLint是用于分析JavaScript代码的原生工具，并且可以为用户提供格式化代码的反馈意见；","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Leetcode刷题","slug":"2019-03-07","date":"2019-07-26T08:10:10.000Z","updated":"2020-07-09T03:18:28.767Z","comments":true,"path":"2019/07/26/2019-03-07/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/26/2019-03-07/","excerpt":"","text":"1 两数之和描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例 123给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] `","categories":[{"name":"刷题","slug":"刷题","permalink":"http://www.hexiaojiao.top/categories/%E5%88%B7%E9%A2%98/"},{"name":"Leetcode刷题","slug":"刷题/Leetcode刷题","permalink":"http://www.hexiaojiao.top/categories/%E5%88%B7%E9%A2%98/Leetcode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"fast-json-patch","slug":"fastJsonPatch","date":"2019-07-26T06:37:10.000Z","updated":"2020-07-09T03:26:36.693Z","comments":true,"path":"2019/07/26/fastJsonPatch/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/26/fastJsonPatch/","excerpt":"","text":"fast-json-patch包使用网上关于json-patch的中文介绍太少了，官方文档没有翻译版，所以写一下自己的学习文档，以下只是自己根据英文文档的理解，不保证正确。 基础操作json patch几大基础操作包括：add, replace, move, test, remove, copy applyPatch给定文档和操作，执行操作 12345678import &#123;applyOperation, applyPatch&#125; from 'fast-json-patch';let document = document = &#123; firstName: \"Albert\", contactDetails: &#123; phoneNumbers: [] &#125; &#125;;let patch = [ &#123; op: \"replace\", path: \"/firstName\", value: \"Joachim\" &#125;, &#123; op: \"add\", path: \"/lastName\", value: \"Wester\" &#125;, &#123; op: \"add\", path: \"/contactDetails/phoneNumbers/0\", value: &#123; number: \"555-123\" &#125; &#125;];const docu = applyPatch(document, patch) applyOperation执行单独的操作而不是连贯操作,举例如下： 1234var document = &#123; firstName: \"Albert\", contactDetails: &#123; phoneNumbers: [] &#125; &#125;;var operation = &#123; op: \"replace\", path: \"/firstName\", value: \"Joachim\" &#125;;document = jsonpatch.applyOperation(document, operation).newDocument;// document == &#123; firstName: \"Joachim\", contactDetails: &#123; phoneNumbers: [] &#125;&#125; applyReducer看了英文原文文档并不很确定，只能根据自己的理解来看。javascript的reduce是一个累加器，使用applyReducer作为累加操作，当定义的操作是一组数组时，使用applyReducer执行操作，示例如下： 12345678var document = &#123; firstName: \"Albert\", contactDetails: &#123; phoneNumbers: [ ] &#125; &#125;;var patch = [ &#123; op:\"replace\", path: \"/firstName\", value: \"Joachim\" &#125;, &#123; op:\"add\", path: \"/lastName\", value: \"Wester\" &#125;, &#123; op:\"add\", path: \"/contactDetails/phoneNumbers/0\", value: &#123; number: \"555-123\" &#125; &#125;];var updatedDocument = patch.reduce(applyReducer, document);// updatedDocument == &#123; firstName:\"Joachim\", lastName:\"Wester\", contactDetails:&#123; phoneNumbers[ &#123;number:\"555-123\"&#125; ] &#125; &#125;; Generating patches提供一个类似于观察者，先获取原始文档结构（observe），之后文档进行变化，最后执行操作，可以得到应有的操作流程。示例如下： 1234567891011var document = &#123; firstName: \"Joachim\", lastName: \"Wester\", contactDetails: &#123; phoneNumbers: [ &#123; number:\"555-123\" &#125;] &#125; &#125;;var observer = jsonpatch.observe(document);document.firstName = \"Albert\";document.contactDetails.phoneNumbers[0].number = \"123\";document.contactDetails.phoneNumbers.push(&#123; number:\"456\" &#125;);var patch = jsonpatch.generate(observer);// patch == [// &#123; op: \"replace\", path: \"/firstName\", value: \"Albert\"&#125;,// &#123; op: \"replace\", path: \"/contactDetails/phoneNumbers/0/number\", value: \"123\" &#125;,// &#123; op: \"add\", path: \"/contactDetails/phoneNumbers/1\", value: &#123;number:\"456\"&#125;&#125;// ]; 比较两个文档-compare直接比较两个文档，得出从文档A到文档B应有哪些操作（得到操作后可以尝试用这个操作来更新B文档） 1234var documentA = &#123;user: &#123;firstName: \"Albert\", lastName: \"Einstein\"&#125;&#125;;var documentB = &#123;user: &#123;firstName: \"Albert\", lastName: \"Collins\"&#125;&#125;;var diff = jsonpatch.compare(documentA, documentB);//diff == [&#123;op: \"replace\", path: \"/user/lastName\", value: \"Collins\"&#125;] 验证修补程序序列对patch做校验，验证这个补丁是否可以应用到指定的对象上（可能是这个意思）,如果出错可以打印出错误信息 12345678910111213141516var obj = &#123;user: &#123;firstName: \"Albert\"&#125;&#125;;var patches = [&#123;op: \"replace\", path: \"/user/firstName\", value: \"Albert\"&#125;, &#123;op: \"replace\", path: \"/user/lastName\", value: \"Einstein\"&#125;];var errors = jsonpatch.validate(patches, obj);if (errors.length == 0) &#123; //there are no errors!&#125;else &#123; for (var i=0; i &lt; errors.length; i++) &#123; if (!errors[i]) &#123; console.log(\"Valid patch at index\", i, patches[i]); &#125; else &#123; console.error(\"Invalid patch at index\", i, errors[i], patches[i]); &#125; &#125;&#125; Json Patch API函数原型： 1function applyPatch&lt;T&gt;(document: T, patch: Operation[], validateOperation?: boolean | Validator&lt;T&gt;, mutateDocument: boolean = true, banPrototypeModifications: boolean = true): PatchResult&lt;T&gt; 对参数的释义： document：将要patch的文档； patch：一个json-patch数组，一组可执行的操作； validateOperation： boolean类型，是否使用默认校验器对每个操作进行校验或通过校验器回调；…其余部分可以自行查文档","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"json-patch","slug":"前端/react/json-patch","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/json-patch/"}],"tags":[{"name":"小工具","slug":"小工具","permalink":"http://www.hexiaojiao.top/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"简单工厂模式","slug":"SimpleFactory","date":"2019-07-24T02:40:10.000Z","updated":"2020-07-09T03:22:57.254Z","comments":true,"path":"2019/07/24/SimpleFactory/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/24/SimpleFactory/","excerpt":"","text":"引入实现计算器代码实现1 实现一个基础的计算器功能，代码见https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/calculator01.php 问题分析（1）错误处理只判断了除数是否为0，对于字符超长，不可计算等都未处理，可以加上try catch；（2）代码不可复用，耦合性很高 使用面向对象处理（1）使用面向对象的方式实现，将输入输出流和逻辑代码分离，可以提高代码复用性，降低耦合，代码见https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate2.php 紧耦合vs松耦合思考：什么情况下使用继承和多态（各种运算可以继承自运算基类，便于扩展，多态考虑输入的不同类型，对于字符串怎样运算）根据以上思考，完成有继承和多态的代码如下：https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate03.php思考：以上代码实现方式虽然使用到了继承，但是如何知道应该调用哪个类呢？难道像之前预估的一样，还是要使用switch判断？ 简单工厂模式解决问题，实例化谁，将来会不会增加实例化的对象等容易变化的地方，考虑用一个单独的类来做这个创造实例的过程在此基础上实现一个简单工厂类，代码如下：https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate04.php如果需要修改运算，可以只修改对应的类，如果需要添加运算，只需要添加运算类，并在工厂中添加对应的分支就可以了简单工厂模式的工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例 工厂方法模式1 简单工厂模式优点：（1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离；（2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可；（3）在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性2 简单工厂模式缺点：（1）工厂类职责过重，它出问题整个系统都会崩溃（2）添加新的类的时候，系统中的简单工厂类都要修改，违反了开放-封闭原则（3）简单工厂的静态方法，使得工厂角色无法形成基于继承的等级结构工厂方法模式每一种算法都对应一种工厂，工厂方法模式优点：（1） 抽象工厂","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"typescript泛型","slug":"genericity","date":"2019-07-22T12:37:10.000Z","updated":"2020-07-08T11:28:40.335Z","comments":true,"path":"2019/07/22/genericity/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/22/genericity/","excerpt":"","text":"typescript泛型介绍","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"typescript","slug":"前端/typescript","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/typescript/"}],"tags":[]},{"title":"抽象工厂模式","slug":"AbstractFactory","date":"2019-07-22T09:40:10.000Z","updated":"2020-07-09T03:22:49.830Z","comments":true,"path":"2019/07/22/AbstractFactory/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/22/AbstractFactory/","excerpt":"","text":"目的在不指定具体类的情况下创建一系列相关或依赖对象。 通常创建的类都实现相同的接口。 抽象工厂的客户并不关心这些对象是如何创建的，它只是知道它们是如何一起运行的。 举例12345678910111213141516171819&lt;?phpclass KuaidiBirdLogic extends BaseLogic&#123; private $basic; private $num; public function __construct(int $num, int $basic) &#123; $this-&gt;num = $num; $this-&gt;basic = $basic; &#125;&#125;class KuaidiOneLogic implements KuaidiBase&#123; private $num; public function __construct(int $num) &#123; $this-&gt;num = $num; &#125;&#125; 定义抽象工厂类 12345678910&lt;?phpclass ExpressFactory extends Model&#123; public function getKuaidiBirdList() &#123; return new KuaidiBirdLogic(12, 13); &#125; public function getKuaidiOneLogic() &#123; return new KuaidiOneLogic(); &#125;&#125; 几种工厂模式的区别抽象工厂模式类似于示例Basic 简单工厂模式工厂方法模式静态工厂模式","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"基础介绍","slug":"dePat","date":"2019-07-22T02:03:10.000Z","updated":"2020-07-09T03:23:20.800Z","comments":true,"path":"2019/07/22/dePat/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/22/dePat/","excerpt":"","text":"#基础介绍 设计具备的特性（1）应该对手头的问题有针对性，同时对将来的问题和需求也要有足够的通用性；（2）避免重复设计或尽可能少做重复设计 什么是设计模式模式四要素模式名称助记名，使用一两个词来描述模式的问题、解决方案和效果 问题描述了应该在何时使用设计模式 解决方案描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式 效果描述了模式应用的效果及使用模式应权衡的问题 模式三种分类创建型与对象的创建有关，在软件工程中，创建型设计模式是处理对象创建机制的设计模式，试图以适当的方式来创建对象。对象创建的基本形式可能会带来设计问题，亦或增加了设计的复杂度。创建型设计模式通过控制这个对象的创建方式来解决此问题。 结构型处理类或对象的组合，通过识别实体之间关系来简化设计的设计模式。 行为型对类或对象怎样交互和怎样分配职责进行描述，识别对象之间的通用通信模式并实现这些模式的设计模式。 通过这样做，这些模式增加了执行此通信的灵活性。","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"}]},{"title":"demo实例","slug":"demo_01","date":"2019-07-18T01:37:10.000Z","updated":"2020-07-09T03:28:13.279Z","comments":true,"path":"2019/07/18/demo_01/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/18/demo_01/","excerpt":"","text":"js正则表达式12345let patt = /[顺丰]/; let reg = new RegExp(patt, 'i'); const company = (reg.test(record.remark) === true) ? 'shunfeng' : 'annengwuliu' console.log('re test-=-----', company); const num = record.remark.replace(/[^0-9]/ig, \"\") 递归读取层级json1234567891011121314151617181920212223242526272829getAllKey (obj: any, name: string, moduleName?: string): any[] &#123; const arr: any[] = [] if (Object.keys(obj)) &#123; let keys = Object.keys(obj); let i = 0; return keys.map((items) =&gt; &#123; i++; if (obj[items] instanceof Object) &#123; // console.log(\"obj[items]:\", items); let itemRes = items; if (obj[items]['type']) &#123; // console.log('it is number:', obj[items]['type']); itemRes = obj[items]['type']; &#125; const names = name + '-' + itemRes return this.getAllKey(obj[items], names, moduleName); &#125; else &#123; // console.log('items:', name + '-' + items); const resItems = name + '-' + items; // console.log('split array:', resItems.split('-')); if (resItems == moduleName) &#123; return this.handleRender(resItems, treeRule.modules, moduleName, i); &#125; &#125; &#125;); &#125;console.log('arr', arr) return arr&#125;","categories":[],"tags":[{"name":"demo","slug":"demo","permalink":"http://www.hexiaojiao.top/tags/demo/"}]},{"title":"react学习-javascript函数式编程","slug":"react_02","date":"2019-07-09T01:37:10.000Z","updated":"2020-07-08T11:28:40.338Z","comments":true,"path":"2019/07/09/react_02/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/09/react_02/","excerpt":"","text":"react学习手册Javascript函数式编程基础概念1 函数式编程：函数是第一类成员，函数就是数据，可以像变量那样被保存，检索或者在应用程序内部传递。（1）可以像声明变量一样声明函数；函数就是变量，可以添加到对象中： 1234567const obj = &#123; message: 'asdsada', log(message) &#123; console.log(message); &#125; &#125;; obj.log(obj.message); （2）可以将函数添加到数组中；（3）函数可以像其他变量一样，作为其他函数的参数传递，也可以作为其他函数的执行结果被返回; 命令式和声明式编程命令式编程：对执行结果的描述胜于执行过程声明式编程： 代码关注重点是达成目标的具体过程 不可变性（1）使用Objct.assign()方法：一种拷贝机制，提供一个空白对象，将操作的对象拷贝到该对象上，然后修改拷贝对象 1Object.assign(&#123;&#125;, color, &#123;rating:rating&#125;) （2）可以使用ES6规范下的箭头函数和ES7规范下的对象扩展运算符编写同样的函数。 1234const rateColor = (color, rating) =&gt; (&#123; ...color, rating&#125;) 注意，在箭头函数中，箭头不能指向一个对象的花括号；Array.push方法不是一个不可变函数，使用Array.concat取代可以使用ES6扩展运算符串联数组，同时改操作符可以使用同样的机制拷贝对象，并将它添加到原生数组的副本上 1const addColor = (title, list) =&gt; [...list, &#123;title&#125;] 纯函数1 概念：返回结果值依赖于输入参数的函数。纯函数至少需要接受一个参数并且总是返回一个值或者其他函数。不产生副作用，不修改全局变量或任何应用程序的state,将输入参数当成不可变数据 1234567891011121314151617181920var frederick = &#123; name: \"Frederick Douglass\", canRead: false, canWrite: false&#125;const selfEducate = person =&gt; (&#123; ...person, canRead: true, canWrite: true &#125;)//// Pure Function, takes an argument, returns an object,// and causes zero side effects//console.log( selfEducate(frederick) )console.log( frederick ) 2 纯函数三条原则：（1）函数应该至少接收一个参数；（2）函数应该返回一个值或者其他函数；（3）函数不应该修改或者影响任何传给它的参数 数据转换1 概念：将数据转换成另外一种数据，使用函数生成转换后的副本2 Array.map和Array.filter方法转换数组3 reduce和reduceRight可以用来将数组转换成任意值。举例：（1）数组转换成数字:以下实例循环迭代，每次返回最大值，然后将结果作为上一次回调函数的返回值 12345678910111213function getAge() &#123; const ages = [10, 21,33, 20,15, 14, 90, 12]; const maxAge = ages.reduce((max, age) =&gt; &#123; console.log(`$&#123;age&#125; &gt; $&#123;max&#125; = $&#123;age &gt; max&#125;`); if (age &gt; max) &#123; return age; &#125; else &#123; return max; &#125; &#125;, 0); const max = ages.reduce((max, value) =&gt; &#123;(value &gt; max) ? value : max&#125;, 0); console.log('maxage', maxAge); &#125; reduceRight和reduce类似，从数组末尾处理元素。（2）数组转化成对象","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[]},{"title":"react学习-es6基础特性","slug":"react_01","date":"2019-07-08T01:37:10.000Z","updated":"2020-07-08T11:28:40.338Z","comments":true,"path":"2019/07/08/react_01/","link":"","permalink":"http://www.hexiaojiao.top/2019/07/08/react_01/","excerpt":"","text":"react学习手册新特性1 react开发者工具：react developer tools，可以查看网站react元素2 yarn进行依赖管理：yarn.lock文件，可以使用yarn install安装，npm install yarn,yarn add [package-name],yarn remove [package-name] 变量声明1 const:常量，不能被修改，重写会报错；2 let:变量，可以将变量作用域限定在任意代码块中（var不行）3 模板字符串${}，可在字符串中插入变量 箭头函数1 介绍：用户可以不使用function关键字创建函数，通常还不需要return2 箭头函数可以限制this的作用域，箭头函数没有自己的this,引用外层的this; ES6转译1 介绍：浏览器运行前将代码转成符合ES5规范的代码，Bable是当前最流行的转译工具之一 ES6的对象和数组1 解构赋值：(1)允许用户将某个对象内的字段的作用域本地化，并且声明哪些值是将要使用的。举例： 123456789101112var sandwich = &#123; bread: \"dutch crunch\", meat: \"tuna\", cheese: \"swiss\", toppings: [\"lettuce\", \"tomato\", \"mustard\"] &#125; var &#123;bread, meat&#125; = sandwich console.log(bread, meat) bread = \"garlic\" meat = \"turkey\" console.log(bread,meat) console.log(sandwich.bread, sandwich.meat) (2)除了使用点符号访问对象内部属性之外，还可以在对象之外解构需要使用的值。 12345678var regularPerson = &#123; firstname: \"Bill\", lastname: \"Wilson\" &#125;; var lordify = (&#123;firstname&#125;) =&gt; &#123; console.log(`$&#123;firstname&#125; of regularPerson`); &#125; lordify(regularPerson); (3)数组中的值也可以被解构，还可以使用都好进行列表匹配，跳过不需要的值； 1234var [firstResort] = [\"Kirkwood\", \"Squaw\", \"Alpine\"] console.log(firstResort)var [, , third] = [\"Kirkwood\", \"Squaw\", \"Alpine\"]console.log(third) 2 对象语义增强可以从全局作用域中获得变量并转化成一个对象。还可以通过对象语义增强或重组构造对象的方法： 123456789let name = 'yaya';let ela = 'test';let func = &#123;name, ela&#125;;let test = function() &#123; console.log(`Mmt. $&#123;this.name&#125; is aa $&#123;this.ela&#125; oo`);&#125;console.log('func', func);let funclike = &#123;name, ela, test&#125;;funclike.test(); 定义了对象方法后就不需要使用关键字function了 123456789101112131415161718// 旧方案var name = \"Léo Taillefer\" var sound = \"Kahh\" var skier = &#123; name: name, sound: sound, powderYell: function() &#123; var yell = this.sound.toUpperCase() console.log(`$&#123;yell&#125; $&#123;yell&#125; $&#123;yell&#125;!!!`) &#125;, speed: function(mph) &#123; this.speed = mph console.log('speed:', mph) &#125; &#125; skier.powderYell() skier.speed(\"hair on fire\") console.log(JSON.stringify(skier)) 123456789101112131415161718// 新方案var name = \"Julia Mancuso\" var sound = \"go fast\" const skier = &#123; name, sound, powderYell() &#123; let yell = this.sound.toUpperCase() console.log(`$&#123;yell&#125; $&#123;yell&#125; $&#123;yell&#125;!!!`) &#125;, speed(mph) &#123; this.speed = mph console.log('speed:', mph) &#125; &#125; skier.powderYell() skier.speed(350) console.log(JSON.stringify(skier)) 3 扩展运算符（1）扩展运算符允许联合数组中的内容： 1234var peaks = [\"Tallac\", \"Ralston\", \"Rose\"]var canyons = [\"Ward\", \"Blackwood\"]var tahoe = [...peaks, ...canyons]console.log(tahoe.join(', ')) （2）可以创建副本，不需要改变数组原生解构 1234var peaks &#x3D; [&quot;Tallac&quot;, &quot;Ralston&quot;, &quot;Rose&quot;]var [last] &#x3D; [...peaks].reverse()console.log(last);console.log(peaks.join(&#39;, &#39;)); （3）可以用来获取数组中的其余元素 1234var peaks = [\"Tallac\", \"Ralston\", \"Rose\", \"te11\", \"tes12\"]var [last, ...rest] = peaks;console.log(last);console.log(rest.join(', ')); （4）可以将函数参数收集到一个数组中 123456789function directions(...args) &#123; var [start, ...remaining] = args var [finish, ...stops] = remaining.reverse() console.log(`drive through $&#123;args.length&#125; towns`) console.log(`start in $&#123;start&#125;`) console.log(`the destination is $&#123;finish&#125;`) console.log(`stopping $&#123;stops.length&#125; times in between`) &#125; directions(\"Truckee\", \"Tahoe City\", \"Sunnyside\", \"Homewood\", \"Tahoma\") （5）适用于对象 12345678910var morning = &#123; breakfast: \"oatmeal\", lunch: \"peanut butter and jelly\"&#125;var dinner = \"mac and cheese\"var backpackingMeals = &#123; ...morning, dinner&#125;console.log(backpackingMeals) Promise对象1 介绍Promise提供了一种更合理的方式处理异步行为,then函数可以通过链式调用执行某些任务，还可以使用另一个回调函数处理异常 1234567891011121314151617const getFakeMembers = count =&gt; new Promise((resolves, rejects) =&gt; &#123; const api = `https://api.randomuser.me/?nat=US&amp;results=$&#123;count&#125;` const request = new XMLHttpRequest() request.open('GET', api) request.onload = () =&gt; (request.status === 200) ? resolves(JSON.parse(request.response).results) : rejects(Error(request.statusText)) request.onerror = (err) =&gt; rejects(err) request.send() &#125;) getFakeMembers(5).then( members =&gt; console.log(members), err =&gt; console.error( new Error(\"cannot load members from randomuser.me\")) ) 类1 背景介绍：以前javascript没有类的概念，类型定义通过函数完成，创建一个函数，通过原型在函数对象上定义方法 1234567891011121314// Constructor and the prototype, the old wayfunction Vacation(destination, length) &#123; this.destination = destination this.length = length&#125;Vacation.prototype.print = function() &#123; console.log(this.destination + \" will take \" + this.length + \" days\")&#125;var maui = new Vacation(\"Maui\", 7)maui.print() 2 新增语法工作机制相同，函数即对象，继承通过原型机制实现 12345678910111213141516class Vacation &#123;constructor(destination, length) &#123; this.destination = destination this.length = length&#125;print() &#123; console.log(`$&#123;this.destination&#125; will take $&#123;this.length&#125; days.`)&#125;&#125;const trip = new Vacation(\"Santiago, Chile\", 9)trip.print() 3 类的继承不仅可以直接继承，还可将类当做抽象类，添加新参数 12345678910111213141516171819202122232425262728293031class Vacation &#123; constructor(destination, length) &#123; this.destination = destination this.length = length &#125; print() &#123; console.log(`$&#123;this.destination&#125; will take $&#123;this.length&#125; days.`) &#125; &#125; class Expedition extends Vacation &#123; constructor(destination, length, gear) &#123; super(destination, length) this.gear = gear &#125; print() &#123; super.print() console.log(`bring your $&#123;this.gear.join(\" and your \")&#125;`) &#125; &#125; const trip = new Expedition( \"Mt. Whitney\", 3, [\"sunglasses\", \"prayer flags\", \"camera\"] ) trip.print() ES6模块1 介绍ES6规范的javascript为模块提供了支持，javascript模块可以存储在独立的文件中，一个文件对应一个模块，创建和导出一个模块中的数据有两种方式，用户可以从一个模块中导出一个或多个javascript对象2 export关键字export可以用来导出会在其他模块中用到的任意javascrip类型数据，其他变量将会以局部变量的形式存在。当值导出一个变量或导出的数据值包含一种类型时，用户可以使用export default 替换export3 import与export相对，在其他javascript文件中调用模块：（1）包含多个export语句的模块还可以进行对象解构（2）使用export default的模块还可以被导入到单个变量中： 1import freel from '/test' （3）可以使用别名实现模块变量的本地化 CommonJS1 介绍：CommonJs是所有版本的node.js都支持的模块模式。用户可以通过Babel和webpack使用，导出使用module.export;CommonJs不支持imporr语句，使用require进行模块导入","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[]},{"title":"virtualbox搭建LANP环境（ubuntu）","slug":"LANP","date":"2019-04-28T06:00:40.000Z","updated":"2020-07-08T11:28:40.331Z","comments":true,"path":"2019/04/28/LANP/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/28/LANP/","excerpt":"","text":"1 基础软件下载virtual boxubuntu(ubuntu server) 2 安装ubuntu(1)virtualbox创建虚拟电脑注意：最好重新设置virtualbox-&gt;管理-&gt;全局设定-&gt;默认虚拟电脑位置(2)启动，网络设置成网络地址转换(NAT)(3)重启的时候需要弹出U盘或者改变镜像位置(4)如果提示未指定nat网络名称，管理-&gt;全局设定-&gt;网络-&gt;nat网络（添加一条）(5) 3 配置ssh(1)添加端口映射（例如2222-&gt;22）,注意主机端口不可重复，且子系统ip不填(2)ubuntu安装ssh 1sudo apt-get install openssh-server (3)xshell等工具连接，端口号为转发的主机端口 4 安装php nginx Mysql(1)安装php 1sudo apt-get install php7.0 (2)安装nginx 1sudo apt-get install nginx (3)安装Mysql 1sudo apt-get install mysql-server-5.7 mysql-client-5.7 5 基础配置(1)安装PHPFastCGI管理器sudo apt install php7.2-fpm 6其他tips(1)配置sudo修改 /etc/sudoers，末尾添加一行： 1test ALL&#x3D;(ALL) NOPASSWD: ALL test表示用户名；保存退出后执行一下命令： 1sudo usermod -aG test test (2)配置共享文件夹且自启动1 virtualbox(设置-共享文件夹-勾选固定分配(不勾选自动挂载))2 ubuntu创建文件夹3 挂载共享文件夹 1sudo mount -t vboxsf filesname &#x2F;mnt&#x2F;filesname 报错可能报错wrong fs type, bad option, bad superblock，经过搜索需要安装apt-get install nfs-common但是安装后依旧报错，查看系统日志，报错信息如下：只查到了一条有用的记录，且是英文的，原来这是virtualbox的一个bug，我记得virtualbox还有一个bug,就是不能在共享文件夹里使用python的虚拟环境，但是这版直接共享文件夹都不能挂载了。路径如下：virtualbox bug再安装两个插件即可 12sudo apt install cifs-utilssudo apt install virtualbox-guest-utils 4 共享文件挂载自启动(3)配置rsa1 windows生成私钥 1ssh-keygen -t rsa -C &lt;your_email@example.com&gt; 2 git配置在git配置上加上公钥3 linux配置对应rsa进入当前用户的home目录(~)，创建.ssh文件夹,复制私钥到文件夹下，进入项目目录，即可执行git clone(可能权限不够，可以暂时把项目目录设置成777) 7 配置1 配置nginx12sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default&#x2F;&#x2F;需要给默认index加上index.php","categories":[],"tags":[]},{"title":"docker使用心得","slug":"docker","date":"2019-04-24T13:03:10.000Z","updated":"2020-07-09T03:25:31.956Z","comments":true,"path":"2019/04/24/docker/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/24/docker/","excerpt":"","text":"准备工作1 前提条件ubuntu内核版本高于 3.10 uname -r 2 安装docker本文是基于ubuntu的，基于centos安装路径博客如下：centoswindows 1wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh 当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker runoob 命令，然后重新登陆启动docker服务 1sudo service docker start 测试运行hello world 1docker run hello-world 镜像加速路径：/etc/docker/daemon.json配置文件中加入(不存在则创建，我本地不存在此文件)： 123&#123; &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125; 基础知识hello world 1docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot; (验证,echo是可以直接echo的，不必写/bin/echo)参数解析docker:docker的二进制执行文件run:与前面docker组合来运行一个容器ubuntu:15.10 : 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。/bin/echo “Hello world”: 在启动的容器里执行的命令运行交互式的容器通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力 1docker run -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash -t:在新容器内指定一个伪终端或终端。-i:允许对容器内的标准输入进行交互启动容器（后台模式） 1docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; 输出一串长字符，是容器ID,对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 ps```可以查看有容器在运行1234CONTAINER ID:容器IDNAMES:自动分配的容器名称在容器内使用docker logs命令，查看容器内的标准输出```docker logs [CONTAINER ID|NAMES] 停止容器docker stop [CONTAINER ID|NAMES](亲测不需要sudo就能停止docker,但是docker ps却需要sudo)##docker容器使用docker命令可以直接查看Docker客户端的所有选项docker comman --help更深入地了解指定地docker命令使用方法","categories":[{"name":"docker","slug":"docker","permalink":"http://www.hexiaojiao.top/categories/docker/"}],"tags":[{"name":"使用心得","slug":"使用心得","permalink":"http://www.hexiaojiao.top/tags/%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"}]},{"title":"gitflow command version","slug":"git","date":"2019-04-24T13:03:10.000Z","updated":"2020-07-09T03:20:47.856Z","comments":true,"path":"2019/04/24/git/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/24/git/","excerpt":"","text":"新建feature/hotfix进行项目开发 更新本地代码仓库缓存git remote updategit checkout developgit merge origin/developgit branch feature/20171012_hotel_enhance ##补充1 删除分支git branch –delete –remotes origin/feature/20190214_monthlygit push origin :feature/20190214_monthly2 add之后回退git reset HEAD 3 撤销commitgit commit –amend4 撤销已经commit但是没有pushgit log 找到commit idgit reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改 git fetch","categories":[{"name":"git","slug":"git","permalink":"http://www.hexiaojiao.top/categories/git/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"gitflow command version","slug":"githubGuide","date":"2019-04-24T13:03:10.000Z","updated":"2020-07-09T03:20:26.243Z","comments":true,"path":"2019/04/24/githubGuide/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/24/githubGuide/","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"http://www.hexiaojiao.top/categories/git/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"Laravel 日志系统","slug":"Log","date":"2019-04-11T07:23:44.000Z","updated":"2020-07-08T12:12:14.354Z","comments":true,"path":"2019/04/11/Log/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/11/Log/","excerpt":"","text":"1 （自己摸索版本）5.21 定义路径.env配置文件添加日志路径，例如 1LOG_PATH&#x3D;&#x2F;tmp&#x2F;paytest 2 启动文件添加日志路径1234$app-&gt;configureMonologUsing(function($logger)&#123; $logger-&gt;pushHandler(new \\Monolog\\Handler\\RotatingFileHandler(env('LOG_PATH').'.log'), 10); return $logger;&#125;); 2 官方文档1 异常处理介绍当您启动一个新的 Laravel 项目时，错误和异常处理就已为您配置。 应用程序触发的所有异常都被 App\\Exceptions\\Handler 类记录下来，然后渲染给用户。 我们将在本文档中深入介绍此类。配置（1）config/app.php 文件的 debug 选项，决定了是否向用户显示错误信息。默认情况下，此选项设置为存储在 .env 文件中的 APP_DEBUG 环境变量中。（2）Laravel 支持 single 、daily 、 syslog 和 errorlog 日志模式。要配置 Laravel 使用的存储机制，应该修改 config/app.php 配置文件中的 log 选项。例如，如果您希望使用每日一个日志文件而不是单个文件，则应将 app 配置文件中的 log 值设置为 daily日志等级使用 Monolog 时，日志消息可能具有不同的日志等级。默认情况下，Laravel 将所有日志级别写入存储。但是，在生产环境中，您可能希望通过将 log_level 选项添加到 app.php 配置文件中来配置应记录的最低日志等级。 一旦配置了此选项，Laravel 将记录大于或等于指定日志等级的所有级别。例如，默认将 log_level 设置为 error 那么将会记录 error , critical , alert 和 emergency 日志信息： 1&#39;log_level&#39; &#x3D;&gt; env(&#39;APP_LOG_LEVEL&#39;, &#39;error&#39;), 注意事项 Monolog 识别以下日志等级 - 从低到高为: debug , info , notice , warning , error , critical , alert , emergencyReport方法所有异常都由 App\\Exceptions\\Handler 类处理。 这个类包含两个方法：report 和 render 。 我们将详细研究这些方法。 report 方法用于记录异常或将其发送到外部服务，如 Bugsnag 或 Sentry 。默认情况下，report 方法只是将异常传递给记录异常的基类。然而，你可以自由选择任何方式进行处理。render方法render 方法负责将异常转换成 HTTP 响应发送给浏览器。默认情况下，异常会传递给为您生成响应的基类。但是，您可以自由检查异常类型或返回您自己的自定义响应 123456789101112131415&#x2F;** * 渲染异常并添加到 HTTP 响应中。 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response *&#x2F;public function render($request, Exception $exception)&#123; if ($exception instanceof CustomException) &#123; return response()-&gt;view(&#39;errors.custom&#39;, [], 500); &#125; return parent::render($request, $exception);&#125; HTTP异常可直接用abort()，例如abort(404),abort(403, ‘Unauthorized action.’);自定义错误页面如果您要自定义404 HTTP状态代码的错误页面，请创建一个 resources/views/errors/404.blade.php 。此文件将会用于渲染所有404错误。此目录中的视图文件命名应与它们对应的HTTP状态代码匹配。由 abort 函数引发的 HttpException 实例将作为 $exception 变量传递给视图。 2 记录介绍默认情况下，Laravel 日志目录为 storage/logs可以传递参数，例如： 12$test &#x3D; &quot;test&quot;;Log::info(222222222, [&#39;te&#39; &#x3D;&gt; $test]);","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"php","slug":"服务端语言/php","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/"},{"name":"laravel","slug":"服务端语言/php/laravel","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/laravel/"}],"tags":[]},{"title":"crontab基本使用","slug":"crontab","date":"2019-04-10T10:27:44.000Z","updated":"2020-07-09T03:22:28.609Z","comments":true,"path":"2019/04/10/crontab/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/10/crontab/","excerpt":"","text":"1 简介crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 2 格式minute hour day month week command 3 操作crontab -l:列出所有任务 laravel 定时任务原文路径 123## 其他解决方式1 supervisor**举例** [program:finance_svcs_autoreconciliation]command=php /opt/app/nginx/html/qa6/financesvcs/artisan queue:work beanstalkd –queue=autoreconciliation_broadcast –daemondirectory=/opt/app/nginx/html/qa6/financesvcsautostart=trueautorestart=trueuser=apachenumprocs=1redirect_stderr=truestdout_logfile=/var/log/supervisor/qa1/%(program_name)s-stdout.logstdout_logfile_maxbytes=10MBstdout_logfile_backups=10 1&#96;&#96;&#96;","categories":[{"name":"linux","slug":"linux","permalink":"http://www.hexiaojiao.top/categories/linux/"},{"name":"crontab","slug":"linux/crontab","permalink":"http://www.hexiaojiao.top/categories/linux/crontab/"}],"tags":[]},{"title":"Mysql分表","slug":"mysqlMerge","date":"2019-04-08T10:27:44.000Z","updated":"2020-07-08T11:28:40.336Z","comments":true,"path":"2019/04/08/mysqlMerge/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/08/mysqlMerge/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[]},{"title":"PHP常见算法","slug":"phpAlg","date":"2019-04-08T10:27:44.000Z","updated":"2020-07-08T11:28:40.337Z","comments":true,"path":"2019/04/08/phpAlg/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/08/phpAlg/","excerpt":"","text":"排序算法1 冒泡排序解析从零开始，每一位和剩余位数比较，如果大于（小于）则交换，最后一位最终会是最大（最小）的。代码 1234567891011121314151617&lt;?php$arr = [2,3,1,4,7,6,9];var_dump(bubbleSort($arr));function bubbleSort($arr)&#123; $len = count($arr); for($i = 0;$i &lt; $len; $i++) &#123; for($j = $len - 1;$j &gt; $i;$j--) &#123; if($arr[$j] &lt; $arr[$j-1]) &#123; $tmp = $arr[$j]; $arr[$j ] = $arr[$j - 1]; $arr[$j - 1] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2 快速排序解析选中一个值（一般是$arr[0]）作为基准，通过一次排序分割成比基准数小和比基准数大的两部分 12345678910111213141516171819202122232425&lt;?php$arr = [3,4,1,5,7,2,6];function quickSort($arr)&#123; if(count($arr) &lt;= 1) &#123; return $arr; &#125; $mid = $arr[0]; $left = array(); $right = array(); for($i = 1;$i&lt;count($arr);$i++) &#123; if($mid &lt; $arr[$i]) &#123; $right[] = $arr[$i]; &#125; else &#123; $left[] = $arr[$i]; &#125; &#125; $left = quickSort($left); $right = quickSort($right); return array_merge($left,array($mid),$right);&#125;var_dump(quickSort($arr)); 注意事项array_merge()需要将左边，中间和右边都合并 查找算法折半查找","categories":[{"name":"php","slug":"php","permalink":"http://www.hexiaojiao.top/categories/php/"}],"tags":[]},{"title":"安装php sniffer","slug":"phpPsr","date":"2019-04-07T10:27:44.000Z","updated":"2020-07-08T11:28:40.337Z","comments":true,"path":"2019/04/07/phpPsr/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/07/phpPsr/","excerpt":"","text":"安装pear（参考文档：https://www.cnblogs.com/huangbx/p/php_codesniffer.html） 从以下网址：http://pear.php.net/go-pear.phar下载代码，或直接另存为文件go-pear.phar 运行php go-pear.phar（注意是否加了环境变量，没有可在php.exe目录下运行） 如果报错“ERROR, enter the php.exe path”，输入选项13，选择php.exe所在目录 安装php sniffer 运行命令“pear install PHP_CodeSniffer” 配置phpstorm（其他IDE请自行Google），Settings-&gt;Languages &amp; Frameworks-&gt;php-&gt;Code Sniffer，选择刚才安装的phpcs.bat文件，validate 看看会不会报错 如果校验报错，可能是找不到autoload路径，打开phpcs文件，更改include路径，例如我可以直接改成include_once ‘/pear/PHP/CodeSniffer/autoload.php’ 选择Settings-&gt;Inspections-&gt;PHP Code Sniffer validation，点击刷新按钮，选择”PSR2” 此时如果有不规范的代码可以看到有phpcs的报错了 配置本地git 打开.git/hooks,新建文件pre-commit 示例代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!&#x2F;bin&#x2F;bash## check PHP code syntax error and standard with phpcs# author : star[github.com&#x2F;star1989]# date : 2017-02-24PROJECT&#x3D;$(git rev-parse --show-toplevel)cd $PROJECTSFILES&#x3D;$(git diff --cached --name-only --diff-filter&#x3D;ACMR HEAD | grep \\\\.php)TMP_DIR&#x3D;$PROJECT.&quot;&#x2F;tmp&quot;# Determine if a file list is passedif [ &quot;$#&quot; -ne 0 ]then exit 0fiecho &quot;Checking PHP Lint...&quot;for FILE in $SFILESdo# echo &quot;php -l -d display_errors&#x3D;0 $&#123;FILE&#125;&quot;# echo &quot;git show :$FILE &gt; $TMP_DIR&#x2F;$FILE&quot; php -l -d display_errors&#x3D;0 $FILE if [ $? !&#x3D; 0 ] then echo &quot;Fix the error before commit.&quot; exit 1 fi FILES&#x3D;&quot;$FILES $PROJECT&#x2F;$FILE&quot;doneif [ &quot;$FILES&quot; !&#x3D; &quot;&quot; ]then echo &quot;Running Code Sniffer...&quot; TMP_DIR&#x3D;&#x2F;tmp&#x2F;$(uuidgen) mkdir -p $TMP_DIR for FILE in $SFILES do mkdir -p $TMP_DIR&#x2F;$(dirname $FILE) git show :$FILE &gt; $TMP_DIR&#x2F;$FILE done phpcs --standard&#x3D;PSR2 --encoding&#x3D;utf-8 -n $TMP_DIR PHPCS_ERROR&#x3D;$? rm -rf $TMP_DIR if [ $PHPCS_ERROR !&#x3D; 0 ] then echo &quot;Fix the error before commit.&quot; exit 1 fifiexit $? 注意这行phpcs –standard=PSR2 –encoding=utf-8 -n $TMP_DIR，在运行git的终端下运行phpcs –help,如果可以运行这行才会生效 此时提交不规范的代码就会报错","categories":[{"name":"php","slug":"php","permalink":"http://www.hexiaojiao.top/categories/php/"}],"tags":[]},{"title":"mongodb使用","slug":"mongo1","date":"2019-04-02T10:27:44.000Z","updated":"2020-07-08T11:28:40.336Z","comments":true,"path":"2019/04/02/mongo1/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/02/mongo1/","excerpt":"","text":"基础 列出所有数据库:show dbs; 列出所有表：show tables;或show collections; 查询所有数据：db.taname.find().pretty(); 查询指定列所有数据：db.tbname.find({},{col1:1,col2:2,…}).pretty(); 根据条件查询所有数据：db.tbname.find({name:”test”},{col1:1,col2:1}).pretty(); 查询结果不包含指定字段：db.tbname.find({},{status:0,col2:0}).pretty();查询1 查询所有数据db.tbname.find().pretty();","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongodb","slug":"数据库/mongodb","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"}],"tags":[]},{"title":"mysql索引优化","slug":"mysqlIndex","date":"2019-04-02T10:27:44.000Z","updated":"2020-07-09T03:25:01.325Z","comments":true,"path":"2019/04/02/mysqlIndex/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/02/mysqlIndex/","excerpt":"","text":"1 查看查询语句执行效率语法explain select … from … [where …]示例 1explain select * from news; 只查询一行数据： 查询多行数据：执行查询执行explain: 2 属性详解 属性 作用 id SELECT的查询序列号 select_type SELECT的查询序列号 table 显示这一行的数据是关于哪张表的 type 显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一 possible_keys 指出MySQL能使用哪个索引在该表中找到行 key 显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL key_len 显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref 显示使用哪个列或常数与key一起从表中选择行 rows 显示MySQL认为它执行查询时必须检查的行数 Extra 包含MySQL解决查询的详细信息，也是关键参考项之一 select_type 类型 解释 SIMPLE 简单SELECT(不使用UNION或子查询等) PRIMARY 最外面的SELECT UNION UNION中的第二个或后面的SELECT语句 DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询 UNION RESULT UNION的结果 SUBQUERY 子查询中的第一个SELECT DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询 DERIVED 导出表的SELECT(FROM子句的子查询) type 索引从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://www.hexiaojiao.top/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"在github上使用Hexo 搭建个人博客","slug":"Hexo","date":"2019-04-01T03:03:10.000Z","updated":"2020-07-09T03:24:46.325Z","comments":true,"path":"2019/04/01/Hexo/","link":"","permalink":"http://www.hexiaojiao.top/2019/04/01/Hexo/","excerpt":"","text":"安装简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。安装前提node.jsgit安装步骤 1npm install -g hexo-cli 建站123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 创建博客1234567891011hexo new [layout] &lt;title&gt; #hexo nhexo generate（或者hexo g:生成静态文件） #hexo ghexo publish [layout] &lt;filename&gt;（发布草稿）hexo server（启动服务器）hexo deploy（或者hexo d:部署）hexo render &lt;file1&gt; [file2] ...（渲染文件）hexo migrate &lt;type&gt;（从其他博客迁移内容）hexo clean（清除缓存文件 (db.json) 和已生成的静态文件 (public)）hexo list（列出网站资料）hexo version（显示 Hexo 版本）#部署使用hexo deploy (hexo d,需要先编译) 添加评论可以使用gitment或者valinevaline评论gitment评论注意事项1 如果添加了CNAME，回调地址需要填绑定的地址2 如果需要开启评论，除了百度能搜到的步骤以外，还需要本地安装博客评论模块npm i –save gitment再重新hexo g -d一下3 作者的服务器停掉了，因此需要修改js源码来源：修改源（也可以wget将源码下载下来后修改源到自己服务器上）","categories":[{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"mysql数据库维护","slug":"mysql数据库维护","date":"2019-03-28T06:03:27.000Z","updated":"2020-07-08T11:28:40.336Z","comments":true,"path":"2019/03/28/mysql数据库维护/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/28/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[]},{"title":"各方法实现微信机器人对比","slug":"wechat","date":"2019-03-28T06:03:27.000Z","updated":"2020-07-08T11:28:40.339Z","comments":true,"path":"2019/03/28/wechat/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/28/wechat/","excerpt":"","text":"wxpy直接排除，只有极少数人的微信可以使用，无法用来实现机器人； 图灵机器人图灵机器人可以接入微信，也可以实现群管理，但是是通过第三方来实现的 功能 详解 是否必要 接入微信公众号 群自动回复 是 主动触发回复 主动往群里发送消息 是 定时发送 定时给群发送消息 是 ### 微群管家 图灵机器人推荐的微信个人号接入第三方插件，但只有windows版本可用，不适用于mac版本开发，但可以实现自定义开发，文档比较全面且免费，可以作为备选方案 功能介绍： 功能 详解 是否必要 关键词自动回复 群自动回复 是 主动触发回复 主动往群里发送消息 是 定时发送 定时给群发送消息 是 收费情况如下： 产品 功能 价格 — — 免费 建议：建议使用微群管家，免费 微友助手也是图灵机器人推荐的个人号接入第三方插件，有后台管理。功能介绍： 功能 详解 是否必要 机器人管理 扫码登录的用户作为机器人，无需邀请新人 是 机器人管理 群数据下载，分析群数据，没太大意义 否 定时群发 可以直接定时群发消息，支持多个群 是 群分组管理 可以给群做一个分组，但是仅限付费群，需要调研收费情况 待定 自动回复 设置关键词后机器人可根据关键词自动回复 是 智能聊天 @机器人后接入图灵机器人自动回复 待定 群文件管理 自动保存群成员发到群内的文件，在群内@机器人，机器人将会回复群文件存放链接 是 成员管理 管理用户，可设置群内权限，也可查看聊天记录 是 踢人 需要机器人本身是群主才能踢人 是 收费情况如下： 产品 功能 价格 微友助手精简版 （机器人聊天+关键词回复）或 （机器人聊天+新人入群欢迎语）或 （机器人聊天+定时发送消息）或（机器人聊天+群数据分析）四选一 79/群/年 微友助手高级版 机器人聊天、群数据分析、新人入群欢迎语、关键词回复、定时群发 99/群/年 微友助手旗舰版 高级版所有功能+潜水/邀请查询，管理员、关键词自动批量踢人，群签到，群精华，群文件管理，群名保护，重复群成员查询去重，发红包、链接、小程序智能提醒及更多扩展功能。 129/群/年 微友助手企业版 包含旗舰版的所有功能，支持购买的群数范围内无限次换群。购买50个以上，问题优先处理，1对1VIP服务。 需要咨询 建议：企业版，可以协调价格 chatie文档地址：https://docs.chatie.io/v/zh/api微群管家也是基于web开发的，微友助手和chatie是通过ipad方式登录，还可以用功能介绍：与微友助手类似 收费情况：如果web版微信可用，免费，否则通过ipad登录收费 产品 功能 价格 token 提供一个类似于微信公众号token，必须自行开发 1920元/年 token 提供一个类似于微信公众号token，可自行开发 1920/年","categories":[{"name":"其他","slug":"其他","permalink":"http://www.hexiaojiao.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"一些php知识","slug":"Laurel","date":"2019-03-28T06:00:40.000Z","updated":"2020-07-08T11:28:40.331Z","comments":true,"path":"2019/03/28/Laurel/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/28/Laurel/","excerpt":"","text":"argc和argv$argv代表传递的参数,$argc代表参数个数（相对路径+传的参数）示例 123456&lt;?phpecho $argv[0]; echo \"\\n\";var_dump($argv[1]); echo \"\\n\";var_dump(intval($argv[2])); echo \"\\n\";echo $argv[3]; echo \"\\n\";echo $argc;","categories":[],"tags":[]},{"title":"重新实现monthly步骤","slug":"monthly","date":"2019-03-25T01:41:10.000Z","updated":"2020-07-08T12:12:31.459Z","comments":true,"path":"2019/03/25/monthly/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/25/monthly/","excerpt":"","text":"1 bi新建已收、已付、应收、应付表1234567891011121314151617CREATE TABLE &#96;order_product_set_pay&#96;(&#96;id&#96; int(10) unsigned NOT NULL,&#96;order_product_id&#96; int(10) unsigned NOT NULL,&#96;parent_order_product_id&#96; int(10) unsigned DEFAULT &#39;0&#39; COMMENT &#39;parent order_product_id&#39;,&#96;has_settlement&#96; decimal(10,2) NOT NULL DEFAULT &#39;0.00&#39;,&#96;should_settlement&#96; decimal(10,2) NOT NULL DEFAULT &#39;0.00&#39;,&#96;has_pay&#96; decimal(10,2) NOT NULL DEFAULT &#39;0.00&#39;,&#96;should_pay&#96; decimal(10,2) NOT NULL DEFAULT &#39;0.00&#39;,&#96;settlement_pay_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,&#96;pay_pay_status&#96; varchar(255) NOT NULL DEFAULT &#39;Pending&#39;,&#96;pay_pay_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;alter table &#96;order_product_set_pay&#96; drop primary key;alter table &#96;order_product_set_pay&#96; add &#96;settlement_id&#96; int(10) unsigned NOT NULL; 2 从bi表中查询数据1 已收（总收）/比例比例 = mysql查询优化优化结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110SELECT op.order_product_id, op.parent_order_product_id, op.product_retail, op.product_discount, op.insurance_retail, op.order_id, op.product_cost, opi.&#96;bill_status&#96; AS bill_status, fs.settlement_id, fs.type, fs.&#96;status&#96;, fs.paid_usd_amount AS should_usd, fs.updated_at AS modify_time, ( SELECT sum(( CASE WHEN (cu.&#96;code&#96;&#x3D;&#39;CNY&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;CNY&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;GBP&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;GBP&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;AUD&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;AUD&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;NZD&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;NZD&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;EUR&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;EUR&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;CAD&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;CAD&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;SUR&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;SUR&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;JPY&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;JPY&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;ZAR&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;ZAR&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;NOK&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;NOK&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;PHP&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;PHP&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;SEK&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;SEK&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;CHF&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;CHF&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;DKK&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;DKK&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;HKD&#39;) THEN ROUND((opii.&#96;amount&#96;)&#x2F;LEFT(SUBSTRING_INDEX(o.rate_info, &#39;&quot;HKD&quot;:&#39;, - 1), 6), 2) WHEN (cu.&#96;code&#96;&#x3D;&#39;USD&#39;) THEN opii.&#96;amount&#96; END )) has_paid FROM &#96;bi&#96;.&#96;order_product_item&#96; opii LEFT JOIN &#96;bi&#96;.&#96;order&#96; AS o ON opii.order_id&#x3D; o.order_id LEFT JOIN &#96;ori_new&#96;.&#96;financial_bill&#96; AS fb ON opii.bill_id&#x3D; fb.id LEFT JOIN &#96;bi&#96;.&#96;order_product&#96; AS opp ON opii.order_product_id&#x3D; opp.order_product_id LEFT JOIN &#96;ori_new&#96;.&#96;tff_provider&#96; tp on opp.provider_id&#x3D;tp.provider_id LEFT JOIN &#96;bi&#96;.&#96;currency&#96; cu on tp.currency_id&#x3D;cu.currency_id WHERE opii.order_product_id &#x3D; op.order_product_id AND ( opii.&#96;bill_status&#96; &#x3D; &#39;Finished&#39; OR opii.&#96;bill_status&#96; &#x3D; &#39;Paid&#39; ) ) has_paid, ( SELECT fb.updated_at FROM &#96;ori_new&#96;.&#96;financial_bill&#96; fb LEFT JOIN &#96;bi&#96;.&#96;order_product_item&#96; opii ON opii.bill_id&#x3D; fb.id WHERE opii.order_product_id &#x3D; op.order_product_id AND opii.&#96;bill_status&#96; &#x3D; &#39;Paid&#39; limit 1 ) &#96;pay_pay_time&#96;, ( SELECT sum(opa.product_retail) AS total_retail FROM &#96;bi&#96;.&#96;order_product&#96; opa WHERE opa.order_id &#x3D; op.order_id AND opa.product_line !&#x3D; &#39;combine&#39; ) total_retail, ( SELECT sum(opa.insurance_retail) AS insurance_total FROM &#96;bi&#96;.&#96;order_product&#96; opa WHERE opa.order_id &#x3D; op.order_id AND opa.product_line !&#x3D; &#39;combine&#39; ) insurance_total, ( SELECT count(opa.order_product_id) AS op_num FROM &#96;bi&#96;.&#96;order_product&#96; opa WHERE opa.order_id &#x3D; op.order_id ) op_num FROM &#96;bi&#96;.&#96;order_product&#96; op LEFT JOIN &#96;bi&#96;.&#96;order_product_item&#96; opi ON op.order_product_id &#x3D; opi.order_product_id LEFT JOIN &#96;ori_new&#96;.financial_settlement AS fs ON fs.order_id &#x3D; op.order_id LEFT JOIN &#96;ori_new&#96;.financial_payment_method AS p ON fs.payment_method_id &#x3D; p.payment_method_id WHERE op.order_product_id in (&#123;0&#125;) AND op.product_line !&#x3D; &#39;combine&#39; 用过的命令12sudo awk -F &#39;[ ;]+&#39; &#39;&#123;if($2&gt;2) print $1,$2&#125;&#39; test.txt | awk &#39;&#123;print $1&#125;&#39; |xargs |tr &quot;\\n&quot; &quot; &quot;|sed &#39;s&#x2F; &#x2F;,&#x2F;g&#39;sudo sed -i &#39;s&#x2F;api.bi.tff.com&#x2F;127.0.0.1:5003&#x2F;g&#39; &#96;find .&#x2F;dist&#x2F; -name &#39;*js&#39;&#96;","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python数据结构之集合","slug":"pythonset","date":"2019-03-15T05:52:00.000Z","updated":"2020-07-08T12:13:01.282Z","comments":true,"path":"2019/03/15/pythonset/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/15/pythonset/","excerpt":"","text":"介绍集合是一个无序的不重复的元素序列操作创建集合：{}或set()，创建一个空集合必须用set()，{}创建空字典(set(“asdgf”)会创建[‘a’, ‘s’, ‘d’, ‘g’, ‘f’],set()创建多个元素需要两个())parame = {value01,value02,…}或set(value)添加元素：s.add(x)s.update(x) -&gt; 参数可以是列表，元组，字典等，x可以有多个，用逗号分开 1234567thisset &#x3D; set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))thisset.update(&#123;1,3&#125;)print(thisset)&#123;1, 3, &#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;&#125;thisset.update([1,4],[5,6]) print(thisset)&#123;1, 3, 4, 5, 6, &#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;&#125; 移除元素：s.remove(x) 将元素x从集合x移除，如果元素不存在则会发生错误s.discard(x) 将元素x从集合x移除，如果元素不存在不会发生错误计算集合元素个数：len(s) 12thisset &#x3D; set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))len(thisset) 返回3清空集合：s.clear()判断元素x是否在集合s中：x in s内置方法 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 删除集合中的元素，该元素在指定的集合中不存在 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False issubset() 判断指定集合是否为该方法参数集合的子集 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中 union() 返回两个集合的并集 update() 给集合添加元素","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python数据结构之列表","slug":"pythonlist","date":"2019-03-15T05:47:00.000Z","updated":"2020-07-08T12:12:57.729Z","comments":true,"path":"2019/03/15/pythonlist/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/15/pythonlist/","excerpt":"","text":"介绍 可以作为一个方括号内的逗号分隔值出现，列表的数据项不需要具有相同的类型操作（1）取值：list[0], list[0:3] （list[-2]代表读取列表中倒数第二个元素）（2）更新列表添加元素：append–&gt; list.append(‘test’)删除元素：del—&gt; del list[2]脚本操作符 python表达式 结果 描述 len([1,2,3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 函数&amp;方法 函数 作用 cmp(list1, list2) 比较两个列表的元素 len(list) 列表元素个数 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 方法 作用 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并返回该元素的值 list.remove(obj) 移除列表中的某个值的第一个匹配项 list.reverse() 反向列表中的元素 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 注意事项 切片：[m:n]从索引m开始，直到索引n为止，但不包括索引n 句尾加逗号：输出在一行中 sort():直接修改原列表，返回None","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python数据结构","slug":"pythonStructure","date":"2019-03-15T01:47:00.000Z","updated":"2020-07-08T12:13:05.152Z","comments":true,"path":"2019/03/15/pythonStructure/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/15/pythonStructure/","excerpt":"","text":"列表(List)python list deque双向队列python deque 集合python set","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python数据结构之双向队列","slug":"pythondeque","date":"2019-03-15T01:47:00.000Z","updated":"2020-07-08T12:12:54.845Z","comments":true,"path":"2019/03/15/pythondeque/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/15/pythondeque/","excerpt":"","text":"介绍两端都可以操作的序列基本操作创建：import collectionsd = collections.deque()往右边添加一个元素：d.append(1)d.append(‘adc’)往左添加一个元素：d.appendleft(3)清空队列：d.clear浅拷贝：d1 = d.copy()返回指定元素的出现次数：d.count(1)从队列右边扩展一个列表的元素：d.extend([3,4,5])从队列左边扩展一个列表的元素：d.extendleft([3,4,5])查找某个元素的索引位置：d.index(“c”, 0, 2) //指定查找区间在指定位置插入元素：d.insert(2,”z”)删除最右边一个元素（返回删除的元素）d.pop()删除最左边一个元素（返回删除的元素）d.popleft()删除指定元素d.remove(“c”)队列翻转d.reverse()把右边元素放左边d.rotate(2) (每个元素向右移动n个，右边元素往左进) feature/20190315_auto_reconcile_loghttp://finance.administration.dev5.tff.com/reconciliation/download?platform=%E9%A9%AC%E8%9C%82%E7%AA%9D&amp;per_page=683&amp;page=1","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"补充python基础知识","slug":"python_base","date":"2019-03-14T07:26:10.000Z","updated":"2020-07-08T12:12:42.807Z","comments":true,"path":"2019/03/14/python_base/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/14/python_base/","excerpt":"","text":"##python运算符幂返回x的y次幂 1020**取整除//:返回商的整数部分，向下取整","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python Generators","slug":"generators","date":"2019-03-14T06:41:10.000Z","updated":"2020-07-08T11:28:40.335Z","comments":true,"path":"2019/03/14/generators/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/14/generators/","excerpt":"","text":"##迭代器Iterator迭代器是一个可以让程序员遍历一个容器的对象，一个迭代器在遍历并读取一个容器的数据元素时不会执行一个迭代。迭代器三个部分可迭代对象迭代器迭代可迭代对象python中的任意对象，只要定义了可以返回一个迭代器的iter方法，或者定义了可以支持下标索引的getitem方法，那么就是一个可跌打对象迭代器任意对象，只要定义了next(Python2)或者next方法，它就是一个迭代器迭代从某个地方取出一个元素的过程，当使用一个循环来遍历某个东西时，这个过程本身就叫做迭代。##生成器Generators生成器也是一种迭代器，但是只能对其迭代一次","categories":[],"tags":[]},{"title":"python debugger","slug":"python_debugger","date":"2019-03-14T03:48:10.000Z","updated":"2020-07-08T12:12:51.603Z","comments":true,"path":"2019/03/14/python_debugger/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/14/python_debugger/","excerpt":"","text":"##准备来源http://python.jobbole.com/81184/初始代码 1234567891011121314import sysdef add(num1&#x3D;0, num2&#x3D;0): return int(num1) + int(num2)def sub(num1&#x3D;0, num2&#x3D;0): return int(num1) - int(num2)def main(): #Assuming our inputs are valid numbers print sys.argv addition &#x3D; add(sys.argv[1], sys.argv[2]) print addition subtraction &#x3D; sub(sys.argv[1], sys.argv[2]) print subtractionif __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 基础用法12import pdbpdb.set_trace() &#x2F;&#x2F;设置断点 在程序中添加断点 12345678910111213141516import pdbimport sysdef add(num1&#x3D;0, num2&#x3D;0): return int(num1) + int(num2)def sub(num1&#x3D;0, num2&#x3D;0): return int(num1) - int(num2)def main(): #Assuming our inputs are valid numbers print sys.argv pdb.set_trace() # &lt;-- Break point added here addition &#x3D; add(sys.argv[1], sys.argv[2]) print addition subtraction &#x3D; sub(sys.argv[1], sys.argv[2]) print subtractionif __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 触发调试器程序会自动在断点处停止执行下一行n输入n运行到下一行打印p可以使用c使pdb跳到末尾或者直到下一个断点如果想知道sys.argv包含的内容，可以输入p sys.argv使用这种方法可以方便地查看变量中实际储存着什么值单步s可以使用s进入函数内部r返回到进入函数的返回语句动态添加断点bb 18:代表在18行设置一个断点列表ll可以显示出此刻在代码中的位置结束qww:显示当前正在执行的代码行的上下文信息a打印当前函数的参数列表","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"python进阶","slug":"python","date":"2019-03-14T02:36:10.000Z","updated":"2020-07-08T12:09:10.388Z","comments":true,"path":"2019/03/14/python/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/14/python/","excerpt":"","text":"args和*kwargs*argsargs和*kwargs主要用于函数定义，可以将不定数量的参数传递给一个函数举例输入： 12345def test_var_args(f_arg, *argv):print(&quot;first normal arg:&quot;, f_arg)for arg in argv:print(&quot;another arg through *argv:&quot;, arg)test_var_args(&#39;yasoob&#39;, &#39;python&#39;, &#39;eggs&#39;, &#39;test&#39;) 输出： 1234first normal arg: yasoobanother arg through *argv: pythonanother arg through *argv: eggsanother arg through *argv: test *kwargskwargs允许将不定长度的键值对作为参数传递给一个函数，如果想在一个函数里处理带名字的参数，应该使用*kwargs使用示例如下： 123456789def getArgs(f_arg, *args): print &quot;first is&quot; + f_arg for arg in args: print &quot;the data is&quot; + arg def gree(**kwa): for key, value in kwa.items(): print(&quot;&#123;0&#125; &#x3D;&#x3D; &#123;1&#125;&quot;.format(key,value))#getArgs(&#39;name1&#39;, &#39;name2&#39;, &#39;name3&#39;, &#39;name4&#39;)gree(name&#x3D;&#39;test&#39;, age&#x3D;12, first&#x3D;&quot;apple&quot;) 输出： 123age &#x3D;&#x3D; 12name &#x3D;&#x3D; testfirst &#x3D;&#x3D; apple 使用args和*kwargs来调用函数如果存在以下函数： 1234def test_args_kwargs(arg1, arg2, arg3):print(&quot;arg1:&quot;, arg1)print(&quot;arg2:&quot;, arg2)print(&quot;arg3:&quot;, arg3) 可以使用args或*kwargs来给这个函数传递参数(1)如果是*args 12args &#x3D; (&quot;two&quot;, 3, 5)test_args_kwargs(*args) 输出： 123arg1: twoarg2: 3arg3: 5 (2)如果是**kwargs 12kwargs &#x3D; &#123;&quot;arg3&quot;: 3, &quot;arg2&quot;: &quot;two&quot;, &quot;arg1&quot;: 5&#125;test_args_kwargs(**kwargs) 输出： 123arg1: 5arg2: twoarg3: 3 (3)标准参数与args、kwargs在使用时的顺序some_func(fargs, args, *kwargs) 使用场景函数装饰器猴子补丁 ##调试**python debugger##生成器和迭代器##Map Filter和Reduce","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[]},{"title":"bash学习笔记","slug":"bash","date":"2019-03-13T06:28:10.000Z","updated":"2020-07-08T11:28:40.332Z","comments":true,"path":"2019/03/13/bash/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/13/bash/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"一些快捷键","slug":"20190220","date":"2019-03-05T05:25:21.000Z","updated":"2020-07-09T03:24:11.050Z","comments":true,"path":"2019/03/05/20190220/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/05/20190220/","excerpt":"","text":"navicat for mysql 快捷键1.ctrl+q 打开查询窗口2.ctrl+/ 注释sql语句3.ctrl+shift +/ 解除注释4.ctrl+r 运行查询窗口的sql语句5.ctrl+shift+r 只运行选中的sql语句6.F6 打开一个mysql命令行窗口7.ctrl+l 删除一行8.ctrl+n 打开一个新的查询窗口9.ctrl+w 关闭一个查询窗口 phpstrom快捷键编辑 快捷键 作用 Ctrl + Space 代码自动完成（一般与输入法冲突） Ctrl + Shift + Enter 智能完善代码（如:if()） Ctrl + P 方法参数提示，显示默认参数 Ctrl + Q 显示注释代码 Ctrl + mouse over code 查看到简短的函数介绍 Ctrl + F1 显示错误或警告信息的描述（需要把光标放到错误或警告位置） Alt + Insert 生成代码段（ 包括函数或类注释，版权信息，构造方法，抽象方法等） Ctrl + O 插入覆盖父类的方法 Ctrl + I 实现抽象方法 Ctrl + Alt + T 选中的代码放在if..else..、for、foreach里,或者函数里，或者为选中的代码块添加区域解释（可以折叠该段代码，折叠后只显示解释，便于代码管理） Ctrl + / 以添加“//”的方式添加注释 Ctrl + Shift + / 添加“/**/”的方式添加注释 Ctrl + W 增量式的选中当前块 Ctrl + Shift + W 与Ctrl + W对应，减小选中范围 Alt + Q 显示包含光标所在位置的标签头 Alt + Enter 显示意图行动。 Show Intention Action Ctrl + Alt + L 格式化代码 Ctrl + Alt + I 自动缩进。 Tab / Shift + Tab 手动缩进/反向缩进 Ctrl + X or Shift + Delete 剪切 Ctrl + C or Ctrl + Insert 复制 Ctrl + V or Shift + Insert 粘贴 Ctrl + Shift + V 从粘贴板中选择内容进行粘贴 Ctrl + D 将当前行或者选择的内容复制到下一行或光标处 Ctrl + Y 删除光标所在的行 Ctrl + Shift + J 合成选中代码到一行。格式化代码的反向动作 Ctrl + Enter 智能线分割 Shift + Enter 另起一新行。无论光标在行的那个位置 Ctrl + Shift + U 字符大小写切换 Ctrl + Shift + ] / [ 以区块为单位，从光标处 向后/向前 选择，再次点击增加选择范围 Ctrl + Delete 删除光标之后的部分单词 Ctrl + Backspace 删除光标之前的部分单词 Ctrl + +/- 折叠/打开代码块，再次点击扩大折叠/打开范围 Ctrl + Shift + + 打开全部 Ctrl + Shift + - 折叠全部 Ctrl + F4 关闭当前页面 搜索/替换 快捷键 作用 Ctrl + F 查找 F3 查找下一个，结合查找使用 Shift + F3 查找前一个，结合查找使用 Ctrl + R 替换 Ctrl + Shift + F 在文件中查找 Ctrl + Shift + R 在文件中替换 被使用搜索 快捷键 作用 Alt + F7 / Ctrl + F7 全项目被使用查找/当前文件声明变量处 Ctrl + Shift + F7 在文件中变量或函数被使用处高亮 Ctrl + Alt + F7 显示详细被使用的位置列表","categories":[{"name":"快捷键","slug":"快捷键","permalink":"http://www.hexiaojiao.top/categories/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[{"name":"文档","slug":"文档","permalink":"http://www.hexiaojiao.top/tags/%E6%96%87%E6%A1%A3/"}]},{"title":"分析bi数据获取流程","slug":"20190213","date":"2019-03-02T05:25:21.000Z","updated":"2020-07-09T03:20:00.423Z","comments":true,"path":"2019/03/02/20190213/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/02/20190213/","excerpt":"","text":"一：导入数据1. bi_etl:通过定时任务脚本将数据从源数据库导出：（1） 修改配置文件，执行dump_order.sh，导入部分测试数据（2）其中mysqldump导出数据到文件中（3）shell无法直接执行source，可以用bash来操作，命令：sudo bash dump_order.sh（4）sh文件可能是在windows下面编辑的，在vim中使用set fileformat=unix 去除\\M字符（5）运行sh文件可在data目录下生成sql文件（6）注意事项： 为什么不使用增量：因为有个中间表没有update_at，financial的表不能随意加字段 1-1修改:（1）第一步导数据，源数据（来自于order_system）已经执行了删除五张表的三个字段，因此导出的数据结构和以前导出的数据结构是不一样的； 2. 通过jump server将bi_etl的数据文件导出到bi_new的upload中(本地无法部署)**（1）由于本地无法直接部署jump server,直接拷贝刚才生成的文件到bi_new的upload中；（2）load_new.sh文件读取的是data.tar.gz压缩文件，因此直接压缩整个data文件夹到upload文件夹下 3. bi_dsvcs读取数据并存入bi_new数据库（1）修改配置文件（不修改可能会覆盖线上数据）（2）执行脚本并去除\\M字符(会读取conf文件，set ff=unix可以去除/r字符)（2）在load_new.sh脚本中（使用了mysql的source命令）将刚才文件中的数据导入ori_new数据库中（4）注意事项：sh文件中使用了tar -xvf 解压data文件，但是实际上没有解压成功，文件不存在，可以直接复制所有文件 3-2修改：（1）执行sql命令直接修改ori_new的结构，命令如下： 12345678910use ori_new;alter table `order_product` add `departure_date` date DEFAULT NULL;alter table `order_product` add `end_date` date DEFAULT NULL;alter table `order_product` add `product_status` int(11) NOT NULL DEFAULT '10000';alter table `order_order_product_combine` drop column `departure_date`, drop column `end_date`, drop column `product_status`;alter table `order_order_product_customize` drop column `departure_date`, drop column `end_date`, drop column `product_status`;alter table `order_order_product_hotel` drop column `departure_date`, drop column `end_date`, drop column `product_status`;alter table `order_order_product_oneday` drop column `departure_date`, drop column `end_date`, drop column `product_status`;alter table `order_order_product_ticket` drop column `departure_date`, drop column `end_date`, drop column `product_status`;alter table `order_order_product_tour` drop column `departure_date`, drop column `end_date`, drop column `product_status`; 4. bi_dpsvc将数据从ori_new中导入到bi库中并合并部分数据（1）module/order.py:__get_order_product_line_table:定义了操作的五张表：order_order_product_oneday、order_order_product_tour，order_order_product_ticket，order_order_product_hotel，order_order_product_combineorder_product_tff表从ori_new就没有导入；order_product_customize单独操作（2）class OrderProduct 4-2修改：（1）bi数据库的order_product表不存在end_date,departure_date两个字段；order_product_customize存在这两个字段，修改方法如下： 1234use bi;alter table `order_product` add `departure_date` date DEFAULT NULL;alter table `order_product` add `end_date` date DEFAULT NULL;alter table `order_order_product_customize` drop column `departure_date`, drop column `end_date`, drop column `product_status`; （2）修改代码","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"Monthly报表完成步骤","slug":"20190214","date":"2019-03-02T05:25:21.000Z","updated":"2020-07-09T03:20:34.412Z","comments":true,"path":"2019/03/02/20190214/","link":"","permalink":"http://www.hexiaojiao.top/2019/03/02/20190214/","excerpt":"","text":"1 计算规则（都在订单产品维度）1 已收（1）计算此订单产品所在的订单的所有已收款（2）计算此订单产品所在的订单有多少订单产品（3）所有已收款除以订单产品数量，平均得出每个订单产品的已收款 2 基础接口实现1 注意事项每次更新代码supervisor都需要重启 2 添加路由和方法创建finance_monthly controller,并在dsvcs.py中引入 3 导入bill表需要导入bill和bill_item表进ori_new以及bi表中","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"vim学习笔记","slug":"vim","date":"2019-02-28T08:34:10.000Z","updated":"2020-07-09T03:25:52.440Z","comments":true,"path":"2019/02/28/vim/","link":"","permalink":"http://www.hexiaojiao.top/2019/02/28/vim/","excerpt":"","text":"光标移动h 或 &lt;- 表示向左j 下k 上l 右 ctrl + f 屏幕向下移动一页ctrl + b 向上移动一页ctrl + d 向下移动半页ctrl + u 向上移动半页‘+’ 光标移动到非空格符的下一行‘-‘ 光标移动到非空格符的n[space] n表示数字，光标向右移动n个字符0或[Home] 移动到这一行最开始的字符处$或[End] 移动到这一行的最后面字符处H 移动到这个屏幕最上方一行的第一个字符M 移动到这个屏幕中央一行的第一个字符L 移动到这个屏幕最下方一行的第一个字符G 移动到这个文件的最后一行nG(:n) 移动到这个文件的第n行gg(1G) 移动到第一行n[Enter] n为数字，表示向下移动n行 查找与替换/word 光标之下寻找名为word的字符串?word 光标之上寻找名为word的字符串n 重复前一个查找的操作N 反向进行前一个查找操作:n1,n2s/word1/word2/g n1和n2是数字，在n1和n2行之间查找所有word,替换成word2:1,$s/word1/word2/g:1,$s/word1/word2/gc c代表confirm,替换前显示确认信息 删除复制与粘贴x 向后删除X 向前删除nx 向后删除n个字符dd 删除（剪切）光标所在一整行ndd 删除向下n行d1G 删除光标所在到第一行的数据dG 删除光标所在到最后一行的数据d$ 删除光标所在处，到该行最后一个字符d0yy 复制该行nyyy1GyGy0y$p 将已复制的数据在光标下一行粘贴P 上一行J 光标所在行与下一行数据结合成同一行c 重复删除多个数据(10cj代表向下删除10行)删除后切换到编辑模式u 回复ctrl+r 重做. 重复前一次操作 进入插入或替换的编辑模式i I i从目前光标所在处插入，I目前所在行的第一个非空格字符处开始插入a A a 从目前光标所在的下一个字符处开始插入,A从光标所在行的最后一个字符处开始插入o O o 在目前光标所在行的下一行处插入新行 O上一行r R r 替换一次 R 一直替换直到按Esc 一般命令模式切换到命令模式ZZ 若文件没有被修改则不保存退出，修改了则保存后退出:w [filename] 将编辑的数据保存成另一个新文件:r [filename] 读入另一个文件的数据，加在光标所在行后面:n1, n2 w [filename] 将n1到n2的内容保存到文件:! command 暂时退出vi到命令行模式下执行command的显示结果（:! ls /home）:set nu:set nonu:e! 还原文件内容事实上，可以使用[ :! ls /home ]不过，如果你学过后面的章节之后，你会发现，执行[ ctrl + z ]亦可暂时退出 vi 让你在命令行 ##多行添加数据 方法一：块选择模式（1）v 进入virtual模式（2）上下键选择需要注释的行数（3）ctrl+v 进入列模式（4）大写I进入插入模式，输入要编辑的符号（5）立即按下两次ESC方法二：替换命令：起始行号，结束行号s/^/注释符/g取消注释：:起始行号,结束行号s/^注释符//g ####编辑多行 ctrl+v进入visual block模式，按两次j或者2j，将光标移动到要插入的最后一行，按下i进入编辑模式。输入内容，Esc退出 ##多文件编辑 :n 编辑下一个文件:N 编辑上一个文件:files 列出目前这个vim打开的所有文件（nyy复制后，使用p粘贴） ##多窗口功能 分区窗口并放入文件:sp {filename} 按键功能介绍:sp [filename] 打开一个新窗口，如果加filename表示打开另一个文件，否则打开自身[ctrl] + w + j 或[ctrl] + w + ↓：先按住ctrl键不放，按下w后放开，之后再按↓或↑ctrl + w + q 相当于切换到某个窗口，按下:q离开，也可以直接ctrl+w+q ##vim的挑字补全功能 ctrl + x -&gt; ctrl + n 通过正在编辑的这个文件的内容文字作为关键组予以补齐ctrl + x -&gt; ctrl + f 以当前目录的文件名作为关键字予以补齐ctrl + x -&gt; ctrl + o 以扩展名作为语法补充，以vim内置的关键字予以补齐 vim 自动补全报错option ‘omnifunc’ is not set编辑vimrc文件，加入以下内容： 1234567autocmd FileType python set omnifunc&#x3D;pythoncomplete#Completeautocmd FileType javascript set omnifunc&#x3D;javascriptcomplete#CompleteJSautocmd FileType html set omnifunc&#x3D;htmlcomplete#CompleteTagsautocmd FileType css set omnifunc&#x3D;csscomplete#CompleteCSSautocmd FileType xml set omnifunc&#x3D;xmlcomplete#CompleteTagsautocmd FileType php set omnifunc&#x3D;phpcomplete#CompletePHPautocmd FileType c set omnifunc&#x3D;ccomplete#Complete ##编码转换 iconv list:列出所有的编码iconv -f 原本编码 -t 新编码 filename [-o newfilw]##vim的环境设置参数 :set no或者:set number:set hlsearch 设置高亮度搜寻:set nohlsearch:set autoindent 自动缩进:set noautoindent 设置不自动缩进:set backup 设置自动储存备份文件，一般设置为nobackup，如果为backup，每次更改一个文件时会自动产生一个filename~文件记录原始文件内容:set ruler 显示右下角状态列:set showmode 是否要显示–INSERT–之类的字眼:set backspace=(012) 某些distribution不允许使用backspace删除字符，当设置值为2可以删除任意值，为0或1时，只能删除刚才输入的:set all 显示目前所有的环境参数设置值:set 显示与系统默认值不同的设置参数:syntax on 程序相关语法显示不同颜色:syntax off:set bg=dark 显示不同的颜色色调:set bg=light 编辑’~/.vimrc’文件，有或没有冒号都可以 ##其他相关操作virtualbox添加共享文件1 设置-添加共享文件，选择固定分配2 添加挂载：sudo mount -t vboxsf rezb2b /mnt/rezb2b3 自启动挂载命令：sudo vim /etc/rc.local 添加命令","categories":[{"name":"快捷键","slug":"快捷键","permalink":"http://www.hexiaojiao.top/categories/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[{"name":"文档","slug":"文档","permalink":"http://www.hexiaojiao.top/tags/%E6%96%87%E6%A1%A3/"}]},{"title":"Hbase基础命令","slug":"20190227","date":"2019-02-28T03:03:10.000Z","updated":"2020-07-09T03:19:43.100Z","comments":true,"path":"2019/02/28/20190227/","link":"","permalink":"http://www.hexiaojiao.top/2019/02/28/20190227/","excerpt":"","text":"Hbase基础命令启动和停止Hbase启动hbase/bin ./start-hbase.sh关闭hbase/bin ./stop-hbase.sh 使用Hbase连接Hbasebin/hbase shell创建表create ‘test’ （创建表需要添加列簇）create ‘表名’ ‘列簇名1’ ‘列簇名2’ ……添加数据put ‘表名’ ‘行名’ ‘列簇名称’ ‘value’（当列簇只有一列）put ‘表名’ ‘行名’ ‘列簇名称：列名称’ ‘value’查看表list: 查看所有表list ‘tablename’ ： 查看表名为tablename的表删除表disable ‘表名’(对应enable ‘明白’)drop ‘表名’ 配置####基础配置conf/hbase-site.xml 注意事项（1）表名，行，列都必须用引号括起来","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Hbase","slug":"数据库/Hbase","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Hbase/"}],"tags":[{"name":"基础命令","slug":"基础命令","permalink":"http://www.hexiaojiao.top/tags/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"}]},{"title":"Monthly报表完成心得","slug":"2019-02-26","date":"2019-02-26T08:10:10.000Z","updated":"2020-07-09T03:20:11.303Z","comments":true,"path":"2019/02/26/2019-02-26/","link":"","permalink":"http://www.hexiaojiao.top/2019/02/26/2019-02-26/","excerpt":"","text":"1 知识点添加日志引入logging包，引入log文件即可 1logging.basicConfig(filename&#x3D;&quot;&#x2F;tmp&#x2F;bi_dsvcs&#x2F;app.log&quot;, level &#x3D; logging.DEBUG) 有四种级别INFO, DEBUG, WARNING, ERROR, CRITICAL, FATAL 获取月份列表需求需要获取月份数据[‘00’, ‘01’, ‘02’, ‘03’, ‘04’, ‘05’, ‘06’, ‘07’, ‘08’, ‘09’, ‘10’, ‘11’]原本解决办法直接定义了一个这样的数组新方法range()从0到13，再在一位数前补零实现代码 12theMonth &#x3D; range(0, 13)monthKey &#x3D; map(lambda x:&#39;%02d&#39; % x, theMonth) 新方法2[“%02d” % x for x in range(1,13)] 数据库导入导出shell脚本里添加mysqldump导出数据导入数据为避免更改表结构，直接mysql -u……连接到库，执行insert操作 gunicorn配置使用supervisor配置gunicorn，我本地虚拟机配置如下 1234567891011[program:bi_dsvcs]command&#x3D;python &#x2F;usr&#x2F;bin&#x2F;gunicorn -c &#x2F;spython&#x2F;bi_dsvcs&#x2F;gunicorn.cnf dsvcs:appprocess_name&#x3D;%(program_name)s&#x2F;%(process_num)ddirectory&#x3D;&#x2F;spython&#x2F;bi_dsvcsnumprocs&#x3D;1autostart&#x3D;trueautorestart&#x3D;trueuser&#x3D;developerredirect_stderr&#x3D;truestdout_logfile&#x3D;&#x2F;tmp&#x2F;bi_dsvcs.interface.info_stdout.logstderr_logfile&#x3D;&#x2F;tmpbi_dsvcs.interface.error_stderr.loga ##2 注意事项 group_concatGROUP_CONCAT()会截断数据，限制长度为1024字节 dictdict不可以直接添加二维数据,需要判断第一维是否已经存在 12345def addtwodimdict(thedict, key_a, key_b, val): if key_a in adic: thedict[key_a].update(&#123;key_b: val&#125;) else: thedict.update(&#123;key_a:&#123;key_b: val&#125;&#125;) list的append()和extend()区别(1)append()接受任意数据类型添加到list尾部(2)extend()只接受list，将这个list每个元素添加到list中 部署后404但是代码确实已部署上去supervisor可能没有重启，重启supervisor或者直接bi_dsvcs/ ./dsvcs restart","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"python100例学习笔记","slug":"20190202","date":"2019-02-02T05:25:21.000Z","updated":"2020-07-09T03:17:22.945Z","comments":true,"path":"2019/02/02/20190202/","link":"","permalink":"http://www.hexiaojiao.top/2019/02/02/20190202/","excerpt":"","text":"四个数组成不重复三位数描述有四个数字，1,2,3,4，能组成多少个不重复的三位数思考原文分析：将所有的数字排列组合后去掉不满足条件的列代码 12345678num &#x3D; 1;for i in range(1,5): for j in range(1,5): for k in range(1,5): if(i !&#x3D; k) and (i !&#x3D; j) and (j !&#x3D; k): print i,j,k num &#x3D; num + 1 print num 扩展循环三次效率很低，每次循环都是1-5，有没有更好的解决办法 2","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"各种奇怪的坑","slug":"2019_01_01","date":"2019-02-01T08:10:10.000Z","updated":"2020-07-09T03:17:37.579Z","comments":true,"path":"2019/02/01/2019_01_01/","link":"","permalink":"http://www.hexiaojiao.top/2019/02/01/2019_01_01/","excerpt":"","text":"1 strtotime()描述获取上个月的时间可以是date(‘Y-m-d’,strtotime(‘-1 month’));如果今天是31号而上个月没有31号，就会直接输出这个月1号；解决办法使用last day of -1 month来获取上个月的最后一天 2 php 字符串和数字比较描述遇到一个问题，传过来的参数可能是0，可能是字符串，然后与0作比较，但是当传递的参数是字符串时，与0比较，结果是true解决办法直接与’0’比较。0===’0’可以返回true,可以直接比较，字符串与’0’比较也不等 3 virtualbox共享文件夹不能执行virtualenv env，只能在其他文件夹下运行，暂时没想到解决办法virtualbox的共享文件夹有保护机制，不允许直接运行virtualenv env，只能在其他文件夹下运行,解决办法：硬链接 4 laravel get()-&gt;toArray()无法获取数据","categories":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"fastadmin自定义角色组","slug":"test-my-site","date":"2019-01-31T09:36:10.000Z","updated":"2020-07-08T12:13:44.671Z","comments":true,"path":"2019/01/31/test-my-site/","link":"","permalink":"http://www.hexiaojiao.top/2019/01/31/test-my-site/","excerpt":"","text":"之前使用fastadmin，自定义角色组，发现编辑/删除/修改等等权限可以直接权限管理中选择，然后用不同的角色登陆，会显示对应的权限按钮。此时有一个新的需求就是增加审核和批量审核，并且也增加对应的权限。 添加按钮 先不写功能，在对应的位置上加上审核按钮。在顶头位置的批量审核需要得到的样式如下： 原先的创建按钮方法为： {:build_toolbar(‘refresh,edit,checkall’)}有时候不使用buid_toolbar来创建按钮，而是直接使用的 &lt;a href=&quot;javascript:;&quot; class=&quot;btn btn-danger btn-del btn-disabled disabled {:$auth-&gt;check(&apos;course/clabelong/del&apos;)?&apos;&apos;:&apos;hide&apos;}&quot;title=”{:(‘Delete’)}” &gt;{:(‘Delete’)} 这种方式来创建按钮，这样虽然很直观，但是实际上使用却很不方便，因为这里对于权限的判定可能是有问题的。期待的结果是直接使用build_toolbar方法，设置checkall为批量审核，check为审核方法，对于各个权限组可以直接调用。修改build_toolbar方法到如下结果： function build_toolbar($btns = NULL, $attr = []) { $auth = \\app\\admin\\library\\Auth::instance(); $controller = str_replace(&apos;.&apos;, &apos;/&apos;, strtolower(think\\Request::instance()-&gt;controller())); $btns = $btns ? $btns : [&apos;refresh&apos;, &apos;add&apos;, &apos;edit&apos;, &apos;del&apos;, &apos;import&apos;,&apos;checkall&apos;]; $btns = is_array($btns) ? $btns : explode(&apos;,&apos;, $btns); $index = array_search(&apos;delete&apos;, $btns); if ($index !== FALSE) { $btns[$index] = &apos;del&apos;; } $btnAttr = [ &apos;refresh&apos; =&gt; [&apos;javascript:;&apos;, &apos;btn btn-primary btn-refresh&apos;, &apos;fa fa-refresh&apos;, &apos;&apos;, __(&apos;Refresh&apos;)], &apos;checkall&apos;=&gt; [&apos;javascript:;&apos;, &apos;btn btn-success btn-checkall btn-disabled disabled&apos;, &apos;fa fa-flag-checkered&apos;, &apos; 批量审核&apos;, &apos;批量审核&apos;], &apos;add&apos; =&gt; [&apos;javascript:;&apos;, &apos;btn btn-success btn-add&apos;, &apos;fa fa-plus&apos;, __(&apos;Add&apos;), __(&apos;Add&apos;)], &apos;edit&apos; =&gt; [&apos;javascript:;&apos;, &apos;btn btn-success btn-edit btn-disabled disabled&apos;, &apos;fa fa-pencil&apos;, __(&apos;Edit&apos;), __(&apos;Edit&apos;)], &apos;del&apos; =&gt; [&apos;javascript:;&apos;, &apos;btn btn-danger btn-del btn-disabled disabled&apos;, &apos;fa fa-trash&apos;, __(&apos;Delete&apos;), __(&apos;Delete&apos;)], &apos;import&apos; =&gt; [&apos;javascript:;&apos;, &apos;btn btn-danger btn-import&apos;, &apos;fa fa-upload&apos;, __(&apos;Import&apos;), __(&apos;Import&apos;)], ]; $btnAttr = array_merge($btnAttr, $attr); $html = []; foreach ($btns as $k =&gt; $v) { //如果未定义或没有权限 if (!isset($btnAttr[$v]) || ($v !== &apos;refresh&apos; &amp;&amp; !$auth-&gt;check(&quot;{$controller}/{$v}&quot;))) { continue; } list($href, $class, $icon, $text, $title) = $btnAttr[$v]; $extend = $v == &apos;import&apos; ? &apos;id=&quot;btn-import-file&quot; data-url=&quot;ajax/upload&quot; data-mimetype=&quot;csv,xls,xlsx&quot; data-multiple=&quot;false&quot;&apos; : &apos;&apos;; $html[] = &apos;&lt;a href=&quot;&apos; . $href . &apos;&quot; class=&quot;&apos; . $class . &apos;&quot; title=&quot;&apos; . $title . &apos;&quot; &apos; . $extend . &apos;&gt;&lt;i class=&quot;&apos; . $icon . &apos;&quot;&gt;&lt;/i&gt; &apos; . $text . &apos;&lt;/a&gt;&apos;; } return implode(&apos; &apos;, $html); }具体修改的就是两个地方，第一个是数组$btns，在$btns数组中添加需要的元素，在本例中添加checkall;第二就是修改$btnAttr，根据需要添加一个checkall元素，如下所示： ‘checkall’=&gt; [‘javascript:;’, ‘btn btn-success btn-checkallbtn-disabled disabled’, ‘fa fa-flag-checkered’, ‘ 批量审核’, ‘批量审核’], 这里有需要特别注意的地方是，最好在类中加上btn-disabled disabled两个class,这样可以方便直接获取是否选择。也就是说，在没有选择项的情况下，所有批量操作的按钮都应该是不能点击的。在修改完buildtoolbar之后在页面上使用应该就是可以直接调用出来了，到此第一步完成。 修改js配置 接下来修改require-table.js文件，因为所有的后台js文件都继承了这个文件，如果用的编辑器或IDE没有历史记录功能那就一定要做好备份。 首先是配置项，extend项代表每个url对应的方法，这里可以设置成缺省为空，然后在需要用到的js文件中再调用。加上checkall和check的URL，最好命名一致，修改完成的extend如下： extend: { index_url: ‘’, add_url: ‘’, edit_url: ‘’, del_url: ‘’, import_url: ‘’, multi_url: ‘’, check_url:’’, checkall_url:’’, check_classes_url:’’, dragsort_url: ‘ajax/weigh’, }只需要按自己的需求把想加的公共方法加上，在config中添加按钮对应的class,比如这里添加： checkallbtn: &apos;.btn-checkall&apos;,绑定事件在bindevent中添加事件如下： // 批量审核按钮事件 $(toolbar).on(&apos;click&apos;, Table.config.checkallbtn, function () { var that = this; var ids = Table.api.selectedids(table); layer.msg(&apos;您正在批量修改审核状态，请选择结果&apos;, { time: 20000, //20s后自动关闭 btn: [&apos;通过&apos;, &apos;不通过&apos;, &apos;取消&apos;] ,yes: function(index){ $(this).data({&apos;check&apos;:1,&apos;tablename&apos;:&apos;classes&apos;}); Table.api.multi(&quot;checkall&quot;, ids, table, $(this)); Layer.close(index); } ,btn2: function(index){ $(this).data({&apos;check&apos;:2,&apos;tablename&apos;:&apos;classes&apos;}); Table.api.multi(&quot;checkall&quot;, ids, table, $(this)); Layer.close(index); } ,btn3: function(index){ Layer.close(index); } }); });其中Table.config.checkallbtn即之前在config中添加的按钮，其中绑定的类名必须在之前的buildtollbar的对应按钮上有，根据需求，这里设置一个弹窗，以点击通过为例：鼠标选择几项结果之后进行批量审核，如果选择通过，对应回调yes，此时设置两个数据，一个是对应的表，一个是审核状态。因为主要是classes表会用到审核，默认值设置为classes表，如果其他方法调用，可以在对应的js文件中重写绑定事件；（还有另一种方法，config中添加一项为tablename,然后直接传tablename,将对应的classes修改为Table.config.tablename,每次页面js调用的时候修改config，但是因为大部分页面用不着重写config,因此这里不这么写）multi方法即批量操作方法，因此这里应该直接调用，在multi方法中有以下的一句：var url = typeof data.url !== “undefined” ? data.url : (action == “del” ? options.extend.del_url : options.extend.multi_url); 这里要注意的是，在js调用的时候打印url，可能审核方法不在，因为实际上multi方法是绑定到dek_url或者multi_url的，这里有两种方法，一种是把check_url替换上去，一种是直接把multi_url方法绑定到check上，也可以直接加上，但是这个判断就要改。 具体js进入到控制器对应的js中调用方法，如果写在trait中，每个控制器都会直接继承，如果使用的地方较少，可以直接使用。地址是admin/library/traits/Backend.phpcheckall方法如下： /** * * 批量审核 */ public function checkall($ids = &quot;&quot;) { $row = $this-&gt;model-&gt;get($ids); if (!$row) $this-&gt;error(__(&apos;No Results were found&apos;)); $adminIds = $this-&gt;getDataLimitAdminIds(); if (is_array($adminIds)) { if (!in_array($row[$this-&gt;dataLimitField], $adminIds)) { $this-&gt;error(__(&apos;You have no permission&apos;)); } } if ($this-&gt;request-&gt;isPost()) { $values = $this-&gt;request-&gt;post()[&apos;params&apos;]; if($values) { $res =Db::name($values[&apos;tablename&apos;])-&gt;where(&apos;id&apos;,&apos;IN&apos;,$ids)-&gt;update([&apos;check&apos;=&gt;$values[&apos;check&apos;]]); $this-&gt;success(); } } }其中$this-&gt;request-&gt;post()[‘params’]可以获取到刚才在js中传递的数据，这里是用户选择的审核状态和需要更新的表名；之后对表进行操作返回$this-&gt;success()就可以了； 添加权限以上操作顺利完成之后显示的会是没有操作权限；首先进入规则管理，添加刚才新增的方法对应的规则，例如这里添加的是check: 只要不以菜单方式显示，然后状态正常就可以了；之后进入角色组，在角色组对应的权限中勾选，此时就可以加上对应的权限，这是很重要的一步： **接下来在index页面中加上验证就行，例如这里是： data-operate-check=&quot;{:$auth-&gt;check(&apos;course/clabelong/check&apos;)}&quot; data-operate-checkall=&quot;{:$auth-&gt;check(&apos;course/clabelong/checkall&apos;)}&quot;**此时再登录不同的用户，例如教师组没有批量审核权限，那么无法显示批量审核按钮。 单个操作权限除了批量操作，其实还可以单个操作，单个操作和批量操作稍有不同，但是更简单。可以仿照单元格元素事件来写，结果如下： &apos;click .btn-checkone&apos;: function (e, value, row, index) { e.stopPropagation(); e.preventDefault(); var table = $(this).closest(&apos;table&apos;); var options = table.bootstrapTable(&apos;getOptions&apos;); var ids = row[options.pk]; row = $.extend({}, row ? row : {}, {ids: ids}); var url = options.extend.check_url; Fast.api.open(Table.api.replaceurl(url, row, table), &apos;审核&apos;, $(this).data() || {}); },直接绑定到check_url，在对应方法的js文件中的extend写出check_url的位置，添加对应的方法和视图，就可以直接调用。当然，同样涉及到权限的问题，加了方法之后在index中依然要用data-operate-check=”{:$auth-&gt;check(‘course/clabelong/check’)}”；同时，不要忘记在require-table.js中添加operate;我添加如下代码： if (options.extend.check_url !== &apos;&apos;) { buttons.push({ name: &apos;check&apos;, icon: &apos;fa fa-flag-checkered&apos;, title: &apos;审核&apos;, classname: &apos;btn btn-xs btn-success btn-checkone&apos;, url: options.extend.check_url }); }在require-table中可能还有需要修改的地方，但是关键是按照原先的add.del等写好的方法来参照，基本上就不会出错了。","categories":[{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"php","slug":"服务端语言/php","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/"},{"name":"fastadmins","slug":"服务端语言/php/fastadmins","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/fastadmins/"}],"tags":[]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/"},{"name":"减肥","slug":"生活/减肥","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/%E5%87%8F%E8%82%A5/"},{"name":"适应期","slug":"生活/减肥/适应期","permalink":"http://www.hexiaojiao.top/categories/%E7%94%9F%E6%B4%BB/%E5%87%8F%E8%82%A5/%E9%80%82%E5%BA%94%E6%9C%9F/"},{"name":"容器","slug":"容器","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/"},{"name":"k8s","slug":"容器/k8s","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/"},{"name":"kustomize","slug":"容器/k8s/kustomize","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/kustomize/"},{"name":"kubenetes权威指南","slug":"容器/k8s/kubenetes权威指南","permalink":"http://www.hexiaojiao.top/categories/%E5%AE%B9%E5%99%A8/k8s/kubenetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式","slug":"学习/设计模式","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"面向对象设计原则","slug":"学习/设计模式/面向对象设计原则","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"docker","slug":"docker","permalink":"http://www.hexiaojiao.top/categories/docker/"},{"name":"php","slug":"php","permalink":"http://www.hexiaojiao.top/categories/php/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"操作系统/linux","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"},{"name":"系统相关","slug":"操作系统/linux/系统相关","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"},{"name":"文件相关","slug":"操作系统/linux/文件相关","permalink":"http://www.hexiaojiao.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"有用代码段收集","slug":"有用代码段收集","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%89%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%94%B6%E9%9B%86/"},{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"},{"name":"测试","slug":"学习/测试","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.hexiaojiao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"前端","slug":"前端","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"数据库","slug":"数据库","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongodb","slug":"数据库/mongodb","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"},{"name":"代码整洁之道","slug":"学习/代码整洁之道","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"},{"name":"代码大全","slug":"学习/代码大全","permalink":"http://www.hexiaojiao.top/categories/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"},{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"刷题","slug":"刷题","permalink":"http://www.hexiaojiao.top/categories/%E5%88%B7%E9%A2%98/"},{"name":"Leetcode刷题","slug":"刷题/Leetcode刷题","permalink":"http://www.hexiaojiao.top/categories/%E5%88%B7%E9%A2%98/Leetcode%E5%88%B7%E9%A2%98/"},{"name":"json-patch","slug":"前端/react/json-patch","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/react/json-patch/"},{"name":"typescript","slug":"前端/typescript","permalink":"http://www.hexiaojiao.top/categories/%E5%89%8D%E7%AB%AF/typescript/"},{"name":"git","slug":"git","permalink":"http://www.hexiaojiao.top/categories/git/"},{"name":"服务端语言","slug":"服务端语言","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/"},{"name":"php","slug":"服务端语言/php","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/"},{"name":"laravel","slug":"服务端语言/php/laravel","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/laravel/"},{"name":"linux","slug":"linux","permalink":"http://www.hexiaojiao.top/categories/linux/"},{"name":"crontab","slug":"linux/crontab","permalink":"http://www.hexiaojiao.top/categories/linux/crontab/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"其他","slug":"其他","permalink":"http://www.hexiaojiao.top/categories/%E5%85%B6%E4%BB%96/"},{"name":"python","slug":"服务端语言/python","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/python/"},{"name":"快捷键","slug":"快捷键","permalink":"http://www.hexiaojiao.top/categories/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Hbase","slug":"数据库/Hbase","permalink":"http://www.hexiaojiao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Hbase/"},{"name":"fastadmins","slug":"服务端语言/php/fastadmins","permalink":"http://www.hexiaojiao.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%AD%E8%A8%80/php/fastadmins/"}],"tags":[{"name":"减肥","slug":"减肥","permalink":"http://www.hexiaojiao.top/tags/%E5%87%8F%E8%82%A5/"},{"name":"学习","slug":"学习","permalink":"http://www.hexiaojiao.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"工作经验","slug":"工作经验","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"},{"name":"tips","slug":"tips","permalink":"http://www.hexiaojiao.top/tags/tips/"},{"name":"测试","slug":"测试","permalink":"http://www.hexiaojiao.top/tags/%E6%B5%8B%E8%AF%95/"},{"name":"go","slug":"go","permalink":"http://www.hexiaojiao.top/tags/go/"},{"name":"概念介绍","slug":"概念介绍","permalink":"http://www.hexiaojiao.top/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"},{"name":"小工具","slug":"小工具","permalink":"http://www.hexiaojiao.top/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"demo","slug":"demo","permalink":"http://www.hexiaojiao.top/tags/demo/"},{"name":"使用心得","slug":"使用心得","permalink":"http://www.hexiaojiao.top/tags/%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"},{"name":"工作","slug":"工作","permalink":"http://www.hexiaojiao.top/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"优化","slug":"优化","permalink":"http://www.hexiaojiao.top/tags/%E4%BC%98%E5%8C%96/"},{"name":"文档","slug":"文档","permalink":"http://www.hexiaojiao.top/tags/%E6%96%87%E6%A1%A3/"},{"name":"基础命令","slug":"基础命令","permalink":"http://www.hexiaojiao.top/tags/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"}]}